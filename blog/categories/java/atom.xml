<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2014-04-10T22:46:22+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[考察对类加载的理解(答案篇)]]></title>
    <link href="http://mccxj.github.com/blog/20131228_classloader-answer.html"/>
    <updated>2013-12-28T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/classloader-answer</id>
    <content type="html"><![CDATA[<h2>独立进程篇</h2>

<p>首先需要知道类加载器是怎么回事? 在Java里边，类加载器就是用来加载类的，然后才是执行代码。<br/>
Java里边默认有启动类加载器(boot),扩展类加载器(ext),和应用类加载器(app)。<br/>
其中boot就是用来加载最开始的虚拟机和最基本的java类，ext是用来加载一些扩展类，默认是在jre/lib/ext目录下的。<br/>
最后一个才是你真正会用到的。cp参数就是用来指定应用类加载器找类的地方，java.ext.dirs就是用来指定
扩展类加载器找类的地方。
这三种类加载器是有层级关系的，类似于继承关系(父子关系)。</p>

<p>另外一个需要知道的概念是，类加载器在找类的时候，默认是采用双亲委派机制的。<br/>
例如应用类加载器加载类的时候，会先叫ext去加载，ext就会叫boot去加载，只有加载不到才尝试自己去加载。<br/>
这种做法是有个重要的因素，就是为了安全性考虑。</p>

<p>最后需要知道的是，TestServlet.class.getClassLoader()获取到的时候，加载TestServlet类所使用的实际的类加载器。</p>

<p>回到上面的问题。</p>

<p>第一个很简单，指定了应用类加载器加载的路径，所以main方法能找到，TestServlet也能找到，config.properties也能被应用类加载器找到。
启动是正常的。</p>

<p>第二个问题，TestServlet是被扩展类加载器加载的，所以通过它来找config.properties会找不到(在应用类加载器中才能被加载到)。</p>

<p>第三个问题，调整目录后，这个时候扩展类加载器的加载路径上也有config.properties，所以启动也会正常。</p>

<p>现在调整了代码，换成了Thread.currentThread().getContextClassLoader()的实现。<br/>
这个是有一点不一样的，上下文类加载器默认就是应用类加载器(如果通过代码进行修改的话)。
上下文类加载器还是一个很有用的技术，
可以用在JDBC这种SPI(Service Provider Interface)接口与实现分离的技术上，有兴趣可以去找找资料。</p>

<p>在这种情况下，后面的三个命令都是能够正常的，因为config.properties能够被正常识别的。</p>

<p>再说一点，用eclipse可以运行的程序，用命令行不一定可以，这点必须要认准最后的启动参数，通过这个来确认。
我们这边写独立进程的时候，贪方便喜欢用java.ext.dirs这个虚拟机参数，但这个有时候会有奇怪的问题。
大家要注意区分这个参数和cp参数的区别，这样就分析有思路，找问题很happy。</p>

<h2>Web应用服务器篇</h2>

<p>像tomcat这种应用服务器，本身也是一个java程序，但它可以把我们放上去的各个web应用隔离开来。
你没法调用其他web应用中的类，看上去好像是完全不相干的。这种技巧就充分利用了自定义类加载器的功能。
像tomcat会对每个应用单独定义一个类加载器(继承应用类加载器)，并且修改双亲委派机制。
而是采用先从应用中的lib目录、classes目录尝试加载，没找到才到上面去找。(像was这种就跟复杂了，加载顺序也是可选的)</p>

<p>所以通常我们会有共享库的概念，在tomcat中对应的就是tomcat_home/lib这个目录(老版本的话还有更多目录可选)。
把一些第三方库放到这里，可以减少加载类的数量，从而减少内存占用。</p>

<p>这里要说明的是，类可以被不同的类加载器加载，虽然是在同一个jvm里边，但是是被当成不同的类(唯一标识是类加载器+类名)。</p>

<p>现在回到问题。虽然一开始就有人告诉我们，servlet是属于单例运行的。但是在这里有点小变化。</p>

<p>第一个问题，这个应该最常规的做法了，appa和appb是不相干的，所以访问appb，输出的是"1 1"，因为两个类是通过不同的类加载器加载的(就是说不一样的类)，肯定生成的servlet实例是不一样的。</p>

<p>第二个问题，这种是共享库的做法，所以实际上他们使用的是同一个类，但是对于不同的app，用的是不同的servlet实例。
所以会出现静态变量有影响，当实例变量是独立的。所以最后会输出"3 1"。所以有维护静态变量的话，使用共享库是有不一样的。</p>

<p>第三个问题，这种其实在生产中也很常见，上新程序的时候就可能变成这样了。其实这个跟第一种情况是一样的。
不过，在was上加载顺序是可选的，所以情况也可能变成第二种情况。</p>

<h2>后话</h2>

<p>这里讲解的只是皮毛，有兴趣的童鞋，可以google更多资料和书籍，加以研究。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[考察对类加载的理解(问题篇)]]></title>
    <link href="http://mccxj.github.com/blog/20131227_classloader-test.html"/>
    <updated>2013-12-27T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/classloader-test</id>
    <content type="html"><![CDATA[<p>类加载和程序运行是有些关系的，不妨来测试一下。<br/>
难度:中级</p>

<h2>独立进程篇</h2>

<p>假设有下面的类文件：</p>

<p>```java
// Main.java
package com.github.mccxj.test;</p>

<p>public class Main {
  public static void main(String[] args){</p>

<pre><code>new TestServlet().test();
</code></pre>

<p>  }
}</p>

<p>// TestServlet.Java
package com.github.mccxj.test;</p>

<p>public class TestServlet {
  public void test() {</p>

<pre><code>InputStream is = TestServlet.class.getClassLoader().getResourceAsStream("config.properties");
if(is == null){
  throw new RuntimeException("couId not found config.properties");
}
</code></pre>

<p>  }
}
```
假设目录结构是这样的，其中jar下面的表示是在jar包里边的内容:</p>

<p>``` bash
test</p>

<pre><code>-lib
    -test.jar
      -com/github/mccxj/test/Main.class
-main.jar
    -com/github/mccxj/test/TestServlet.class
    -config.properties
</code></pre>

<p>```</p>

<p>请问：</p>

<ol>
<li>执行java -cp main.jar;lib/test.jar com.github.mccxj.test.Main会出错么？</li>
<li>执行java -cp main.jar -Djava.ext.dirs=./lib com.github.mccxj.test.Main结果是怎样？</li>
</ol>


<p>继续调整目录结果如下：</p>

<p>``` bash
test</p>

<pre><code>-lib
    -test.jar
        -com/github/mccxj/test/Main.class
    -main.jar
        -com/github/mccxj/test/TestServlet.class
        -config.properties
</code></pre>

<p>```</p>

<p>再请问</p>

<ol>
<li>执行java -Djava.ext.dirs=./lib com.github.mccxj.test.Main结果是怎样？</li>
</ol>


<p>继续调整一下TestServlet的代码：</p>

<p>```diff
// TestServlet.Java
package com.github.mccxj.test;</p>

<p>public class TestServlet {
  public void test() {
-    InputStream is = TestServlet.class.getClassLoader().getResourceAsStream("config.properties");
+    InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream("config.properties");</p>

<pre><code>if(is == null){
  throw new RuntimeException("couId not found config.properties");
}
</code></pre>

<p>  }
}
```</p>

<p>把目录结构恢复成：</p>

<p>``` bash
test</p>

<pre><code>-lib
    -test.jar
      -com/github/mccxj/test/Main.class
-main.jar
    -com/github/mccxj/test/TestServlet.class
    -config.properties
</code></pre>

<p>```</p>

<p>请问:</p>

<ol>
<li>执行java -cp   main.jar;lib/test.jar com.github.mccxj.test.Main会出错么？</li>
<li>执行java   -cp main.jar -Djava.ext.dirs=./lib com.github.mccxj.test.Main结果又是怎样？</li>
</ol>


<p>最后调整目录结果如下：</p>

<p>``` bash
test</p>

<pre><code>-lib
    -test.jar
        -com/github/mccxj/test/Main.class
    -main.jar
        -com/github/mccxj/test/TestServlet.class
        -config.properties
</code></pre>

<p>```</p>

<ol>
<li>执行java -Djava.ext.dirs=./lib com.github.mccxj.test.Main结果是怎样？</li>
</ol>


<h2>Web应用服务器篇</h2>

<p>下面的例子，以tomcat为例。
假设有下面的Servlet文件，并打包成test.jar:</p>

<p>```java
// TestServlet.java
package com.github.mccxj.test;</p>

<p>public class TestServlet extends HttpServlet {</p>

<pre><code>private static Atomiclnteger al = new AtomicInteger();
private Atomiclnteger a2 = new AtomicInteger();

@Override
public void service(ServletRequest arg0, ServletResponse arg1) throws Servlet Exception, IOException {
    System.out.printIn(String.valueOf(al.incrementAndGet()));
    System.out.printIn(String.valueOf(a2.incrementAndGet()));
}
</code></pre>

<p>}
```</p>

<p>并部署两个应用程序appa、appb,在他们的WEB_INF/web.xml添加了下面的内容</p>

<p><code>xml
&lt;servlet&gt;
  &lt;servlet-name&gt;test&lt;/servlet-name&gt;
  &lt;display-name&gt;test servlet&lt;/display-name&gt;
  &lt;servlet-class&gt;com.huawei.test.TestServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;test&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/test&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></p>

<p>大家应该听说过Servlet是单例的概念，也可能听过Web应用服务器有共享类的机制。那么，请问：</p>

<ol>
<li>现在把test.jar扔到appa和appb的WEB_INF/lib目录中，启动tomcat，先访问/appa/test两次，再访问/appb/test, 此时会输出什么？</li>
<li>继续把test.jar都移除掉，只添加到TOMCAT_HOME/lib目录中，启动tomcat，先访问/appa/test两次，再访问/appb/test, 此时会输出什么？</li>
<li>最后把test.jar拷贝一份到appa的WEB_INF/lib目录中，启动tomcat，先访问/appa/test两次，再访问/appb/test, 此时会输出什么？</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[由于MANIFEST.MF不规范导致程序无法启动的问题]]></title>
    <link href="http://mccxj.github.com/blog/20131226_manifest.html"/>
    <updated>2013-12-26T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/manifest</id>
    <content type="html"><![CDATA[<p>昨晚发现某个jar程序启动不了，包类没找到。
这个是由于我增加了一个新的jar包，并且依赖于xwork.jar。
所以在build.xml里边增加这个jar包。</p>

<p>```xml</p>

<pre><code>    &lt;fatjar.build output="ibossproc.jar"&gt;
  ...
    &lt;fatjar.jarsource file="${buildlib}/jsse.jar" relpath=""/&gt;
    &lt;fatjar.jarsource file="${buildlib}/cipher14.jar" relpath=""/&gt;
    &lt;fatjar.jarsource file="${buildlib}/xwork-2.0.4.jar" relpath=""/&gt;
&lt;/fatjar.build&gt;
</code></pre>

<p>```</p>

<p>不过还是出错，出错信息挺诡异的(用星号对某些信息进行屏蔽)：</p>

<p>```java
mccxj@XXX:/work/procs/log> cat *
线程 "main" 中发生异常java.lang.NoClassDefFoundError: com.<em>.</em>.<em>.</em>Entry
Caused by: java.lang.ClassNotFoundException: com.<em>.</em>.<em>.</em>Entry</p>

<pre><code>    at java.net.URLClassLoader.findClass(URLClassLoader.java:421)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:652)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:346)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:618)
</code></pre>

<p>Could not find the main class: com.<em>.</em>.<em>.</em>Entry.  Program will exit.
```</p>

<p>这个类是程序里边的代码，应该是存在的。把jar解压了，也的确看到jar包里边有这个类。</p>

<p>于是把以前能跑的jar拿来进行对比，发现META-INF/MANIFEST.MF稍稍有点不同，新的在最后多了2个空行。
简单调整了一下打包脚本（用的一个fatjar.jar的工具）,最后两行进行调整顺序，发现就可以了。</p>

<p>```xml</p>

<pre><code>    &lt;fatjar.build output="xx.jar"&gt;
  ...
    &lt;fatjar.jarsource file="${buildlib}/jsse.jar" relpath=""/&gt;
    &lt;fatjar.jarsource file="${buildlib}/xwork-2.0.4.jar" relpath=""/&gt;
    &lt;fatjar.jarsource file="${buildlib}/cipher14.jar" relpath=""/&gt;
&lt;/fatjar.build&gt;
</code></pre>

<p>```</p>

<p>一开始感觉是fatjar.jar的bug，不过回过头来看，其实是cipher14.jar这个包的问题。<br/>
因为这个包的META-INF/MANIFEST.MF的最后一样是个问号，根据<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR%20Manifest">规范文档</a>,
这个是不规范的。如：</p>

<p>```java
Manifest-Version: 1.0</p>

<p>?
```</p>

<p>而fatjar会把所有的MANIFEST.MF进行合并，但是奇怪的地方就在这里了。如果问号是在最后一样，能够正常启动。 <br/>
如果问号后面还有内容，就启动不了。所以调整顺序之后，能够正常启动。<br/>
后来，我把cipher14.jar的MANIFEST.MF中的问号去掉，不需要调整顺序也是可以正常的。</p>

<p>这个包应该是第三方厂商提供的，又踩地雷了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从流关闭说起]]></title>
    <link href="http://mccxj.github.com/blog/20130821_java-hell-stream-close.html"/>
    <updated>2013-08-21T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/java-hell-stream-close</id>
    <content type="html"><![CDATA[<h3>基本原则: 谁生产谁销毁</h3>

<p>这个是用来解决责任权的问题，例如你的方法接收一个InputStream作为参数，通常就不应该在方法内去关闭它，而由客户端代码去处理。如果要关闭，通常应该在方法签名上明确说明，具体样例参考commons-io的IOUtils类。</p>

<p>还有另外一个例子，就是经常使用的Servlet的输入输出流，根据这个原则，也是不应该在代码中进行关闭的，这个工作是由Web容器负责的。</p>

<h3>关闭的是什么?</h3>

<p>java本身是带GC的，所以对象在消除引用之后，按正常是能够被回收的，那么为什么会有关闭操作?</p>

<p>这是为了回收系统资源，主要是端口(网络IO),文件句柄(输入输出)等，通常涉及的场景也是操作文件，网络操作、数据库应用等。对于类unix系统，所有东西都是抽象成文件的，所以可以通过lsof来观察。</p>

<p>为了更详细的说明这点，我们可以测试一下下面的代码:</p>

<p>```java
public class Hello {</p>

<pre><code>public static void main(String[] args) throws Exception {
    for (int i = 0; i &lt; 100; i++) {
        FileInputStream is = new FileInputStream("/tmp/data/data"+i);
        byte[] bs = new byte[512];
        int len;
        while ((len = is.read(bs)) != -1) ;
        Thread.sleep(1000L);
    }
    Thread.sleep(10000L);
}
</code></pre>

<p>}
```</p>

<p>运行之后，通过losf或进程目录查看相关的文件句柄数量是不断增长的:</p>

<p>```bash
lsof -p 25945 |grep /tmp/data | wc -l
88</p>

<p>ls  /proc/25945/fd | wc -l
93
```</p>

<p>如果有关闭操作的话，就会发现打开文件数一直都处于很低的位置。如果持续出现未关闭的情况，积累到一定程度就可能超过系统限制，出现too many open files的错误。</p>

<h3>如何确保关闭</h3>

<p>关闭通常是调用close()方法来实现的，并且需要在finally来进行处理。另外，我们经常会遇到多个资源的关闭情况，因为IO库是采用修饰器模式的，所以基本原则是先关闭外层对象，再关闭内层对象，每个close调用都需要处理异常情况，例如:</p>

<p>```java
InputStream is = null;
OutputStream os = null;
try{
   // ...
}
finally{
  if(is != null)</p>

<pre><code> try{
   is.close();
 }
 catch(IOException e){}
</code></pre>

<p>  if(os != null)</p>

<pre><code> try{
   os.close()
 }
 catch(IOException e){}
</code></pre>

<p>}
```</p>

<h3>实践</h3>

<ul>
<li>上面的关闭处理的确是比较繁琐的，可以考虑进行封装或者直接使用IOUtils.closeQuietly方法，节约不少代码行。</li>
<li>自从JDK5之后，需要进行关闭处理的对象可以考虑实现java.io.Closeable接口。这个可以让资源关闭使用同一套代码。</li>
</ul>


<h3>JDK7改进及其他思路</h3>

<p>在JDK7里，你只需要将资源定义在try()里，Java7就会在readLine抛异常时，自动关闭资源。
但是资源类必须实现java.lang.AutoCloseable接口，同时支持管理多个资源,释放次序与声明次序相反。</p>

<p>```java
try (BufferedReader br = new BufferedReader(new FileReader(path)) {</p>

<pre><code>return br.readLine();
</code></pre>

<p>}
```</p>

<p>虽然感觉总是很繁琐，语法糖味道重，但比以前倒是进步不少了。
不过我们还是来看看Go中的做法，它提供了defer操作，用于在脱离方法作用域的时候自动调用，有点析构的味道。
看下面的示例:</p>

<p>```go
func main() {</p>

<pre><code>files, err := os.Open("testqq.txt")        
if err != nil {
    fmt.Printf("Error is:%s", "Game Over!")
    return
}
defer files.Close()
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[说说字符串拼接]]></title>
    <link href="http://mccxj.github.com/blog/20130809_java-hell-string-append.html"/>
    <updated>2013-08-09T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/java-hell-string-append</id>
    <content type="html"><![CDATA[<h3>String对象是无状态的</h3>

<p>String的内部属性在初始化的时候就固定好了，也没有提供方法进行修改(反射等极端方法除外)，并且类被定义成final，所以String对象都是是实实在在的无状态对象，是不可变的。</p>

<p>在通常的字符串拼接中，如果采用+运算符的话，通常会产生一个字符串对象，并把两个字符串的内部字符数组拷贝过去。
因此，在一个常见的频繁修改字符串的场景中，字符数组的拷贝开销是很大的，随之字符串的加长会越到后面越慢,例如下面的代码。</p>

<p><code>java
String sb = "";
for(String str : strs){
  sb += str;
}
return sb;
</code></p>

<h3>StringBuffer与StringBuilder</h3>

<p>jdk早就考虑了这种场景，于是提供了StringBuffer，简单来说，就是一个可变的字符数组，开辟了一个字符数组缓冲区，增加(Append)时只是往缓冲区的空余地方写字符，当然也有可能缓冲区不够用，它的开销就集中在不够用的缓冲区扩展中(每次在现有基础上扩展一倍空间)。所以，最好能提前估计字符串的最终长度，减少扩展造成的消耗。不过，即便如此，通常也要把直接用String拼接的效率高许多，例如下面的代码。</p>

<p><code>java
StringBuffer sb = new StringBuffer();
for(String str : strs){
  sb.append(str);
}
return sb.toString();
</code></p>

<p>到了jdk5，增加了StringBuilder，相对于StringBuffer来说，虽然它不是线程安全的，但在绝大多数场景下都是适用的，并且理论效率更佳(从oracle jdk的实现看，两个类除了是否同步这点，实现是一致的)。因此，习惯使用StringBuffer的童鞋，应该多关注一下StringBuilder。</p>

<h3>字符串拼接的编译优化</h3>

<p>再回到+操作符，本身java是没有运算符重载的，+只会对基本数学运算有效，而字符串，这么写只是语法糖而已，会变成StringBuilder操作(jdk5之前是StringBuffer)。例如下面的代码:</p>

<p><code>java
public String test(String a){
   return a + "b";
}
</code></p>

<p>通过javap查看，可以看到是这样的(大意就是new一个StringBuilder对象然后用append进行连接);</p>

<p><code>java
public java.lang.String test(java.lang.String);
  Code:
   Stack=2, Locals=2, Args_size=2
   0:   new     #2; //class java/lang/StringBuilder
   3:   dup
   4:   invokespecial   #3; //Method java/lang/StringBuilder."&lt;init&gt;":()V
   7:   aload_1
   8:   invokevirtual   #4; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
   11:  ldc     #5; //String b
   13:  invokevirtual   #4; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
   16:  invokevirtual   #6; //Method java/lang/StringBuilder.toString:()Ljava/lang/String;
   19:  areturn
  LineNumberTable:
   line 3: 0
</code></p>

<p>因此，如果是像上面的情况，直接用+是合理的，对于其他情况，得考虑StringBuilder，同时要避免无意生成多余字符串的情况，例如append("s" + a)的写法，编译器是不会自动优化的，写代码的时候应该换成append("s").append(a)。</p>

<p>更多关于字符串不变量的讨论，请见<a href="http://mccxj.github.io/blog/20130615_java-string-constant-pool.html">初探Java字符串</a></p>
]]></content>
  </entry>
  
</feed>
