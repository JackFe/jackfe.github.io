<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: des | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/des/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2016-04-26T21:56:16+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[常见DES实现陷阱]]></title>
    <link href="http://mccxj.github.com/blog/20141229_des-hack.html"/>
    <updated>2014-12-29T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/des-hack</id>
    <content type="html"><![CDATA[<h3>DES要点说明</h3>

<ul>
<li>DES走的是分组加密，每次处理对象的是8位byte，所以对字符串加解密的时候，会涉及字符编码格式和补齐8位的问题。</li>
<li>DES的密钥是固定8位的byte的，其中前7位是加解密用的，最后一位是校验码。</li>
<li>3DES的增强型的DES，带3个key，如果3个key一样，就是DES，也有一种变种是1、3是一样的。但都是固定8位的。</li>
<li>3DES通常是EDE,就是先加密(k1)再解密(k2)再加密(k3)</li>
</ul>


<p>目前，项目代码中有3个和DES实现相关的类,下面看看他们有哪些问题：</p>

<h3>案例1</h3>

<ul>
<li>从字符串到byte的转换，有指定编码格式GBK，这个是可以接受的。</li>
<li>使用的是DESede,就是3DES的EDE加密方式，但是3个key是一样的，没有意义。</li>
<li>加密时代码先自行进行了补齐操作(补\0),但是补齐是在字符串上操作的，不是在字节上操作，导致实际上可能没有对齐(中文情况)。</li>
<li>调用加密API时，没有指定补齐方式，会采用默认补齐，造成重复补齐(当然也修复了上面的补齐操作)。</li>
<li>解密指定NoPadding，和加密Padding方式不一样，造成解密结果最后会出现很多多余的字节。所以结果必须得trim一下才行。</li>
</ul>


<p>参考代码如下：</p>

<p>补齐实现有误：
```java</p>

<pre><code>public String encrypt(String in) throws Exception {
    String strIn = in;
    if (null == strIn || "".equals(strIn)) {
        return "";
    }

    int i = 0;
    i = strIn.length() % 8;

    if (0 == i) {
        for (i = 0; i &lt; 8; i++) {
            strIn += "\0";
        }
    } else {
        while (i &gt; 0) {
            strIn += "\0";
            i--;
        }
    }
    byte[] bytes = strIn.getBytes(CHARSET);
    byte[] enbytes = encryptCipher.doFinal(bytes);
    return byteArrToHexStr(enbytes);
}
</code></pre>

<p>```</p>

<p>key是一样的，补齐方式没对应上：
```java</p>

<pre><code>public DESedeEncrypt() {
    byte[] buffer = new byte[] {
            0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
            0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31
    };

    SecretKeySpec key = new SecretKeySpec(buffer, "DESede");

    try {
        encryptCipher = Cipher.getInstance(KEY_ALGORITHM);
        encryptCipher.init(Cipher.ENCRYPT_MODE, key);
        decryptCipher = Cipher.getInstance("DESede/ECB/NoPadding");
        decryptCipher.init(Cipher.DECRYPT_MODE, key);
    } catch (NoSuchAlgorithmException e) {
        Throwables.propagate(e);
    } catch (NoSuchPaddingException e) {
        Throwables.propagate(e);
    } catch (InvalidKeyException e) {
        Throwables.propagate(e);
    }
}
</code></pre>

<p>```</p>

<h3>案例2</h3>

<ul>
<li>从字符串到byte的转换，采用了系统默认编码，存在平台移植性问题。</li>
<li>密钥key的长度布置8位，有多余字符(虽然只取前8位避免出错)，造成混乱。</li>
</ul>


<p>key的格式不标准，有多余字符:
```java</p>

<pre><code>private static String strDefaultKey = "mywebsite123456%";
private Key getKey(byte[] arrBTmp) throws Exception {
    byte[] arrB = new byte[8];
    for (int i = 0; i &lt; arrBTmp.length &amp;&amp; i &lt; arrB.length; i++) {
        arrB[i] = arrBTmp[i];
    }

    Key key = new javax.crypto.spec.SecretKeySpec(arrB, "DES");

    return key;
}
</code></pre>

<p>```</p>

<h3>案例3</h3>

<ul>
<li>从字符串到byte的转换，采用了系统默认编码，存在平台移植性问题。</li>
<li>实现不是标准的DES，或3DES，是在DES基础上定义了一套加密。</li>
<li>根据目前key的长度，比标准3DES都要慢很多，另外没有采用JDK带的API。</li>
</ul>


<p>key的长度不标准：
```java
public class DesUtil {</p>

<pre><code>public static final String firstKey = "com.xxx.xxxpro";
public static final String secondKey = "xxx_web";
public static final String thirdKey = "xxxservice";
</code></pre>

<p>}
```</p>

<p>实现方式是对每个key补齐8位，再切割形成每组多个8位的key，再采用EEE的方式进行处理:
```java</p>

<pre><code>                    for (x = 0; x &lt; firstLength; x++) {
                        tempBt = enc(tempBt, (int[]) firstKeyBt.get(x));
                    }
                    for (y = 0; y &lt; secondLength; y++) {
                        tempBt = enc(tempBt, (int[]) secondKeyBt.get(y));
                    }
                    for (z = 0; z &lt; thirdLength; z++) {
                        tempBt = enc(tempBt, (int[]) thirdKeyBt.get(z));
                    }
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DES加解密总结]]></title>
    <link href="http://mccxj.github.com/blog/20130930_des.html"/>
    <updated>2013-09-30T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/des</id>
    <content type="html"><![CDATA[<p>DES是广泛使用的分组对称加密算法，它要求待加密数据要8位对齐，所以在数据不足8位时候会出现padding的情况，
所以有可能因为padding不同，而出现加解密结果不一样，这种情况在异构系统间的数据通信特别容易出现，例如java和cpp系统之间的通信。
如果在开发过程中，遇到不同语言加解密结果不一样的情况，应该关注一下补齐方式。
关于补齐方式，请参考http://en.wikipedia.org/wiki/Padding_%28cryptography%29</p>

<p>先说说java这里，java api已经集成了DES加解密算法，如果不指定补齐方式的话，默认的补齐方式是使用PKCS5Padding，
这种情况下，长度不足8字节的部分，填充“0x01”—“0x08”，如不
足1字节，则填充1个“0x01”，如不足2字节，则填充2个“0x02”，以此类推。更具
体的描述，参考<a href="http://www.herongyang.com/Cryptography/DES-JDK-What-Is-PKCS5Padding.html">What Is PKCS5Padding?</a>
如果我们指定补齐方式，如使用DES/ECB/NoPadding的话(其中ECB是加密的模式，也是默认的加密方式)，就需要自己手动补齐，例如补空格字符。
现在的代码为了和后台的加解密结果一致，采用的是手动补齐的方式，即NoPadding方式。</p>

<p>如果cpp实现的padding方式和java的不一致，就可能导致加解密失败。在我们的系统里边，cpp实现的padding是补\0的。
这个字符在显示的时候就直接被当成结束符了，无需特殊处理。所以，如果使用java加密，cpp解密的话，
java这边也要使用补\0的做法，如果使用java解密的话，就只能使用trim进行处理了。</p>

<p>以我们这边使用的两个DES相关的接口为例，用户鉴权接口在配置里边有使用trim进行处理，而wlan密码认证接口没有使用trim处理。
因此按现在使用补空格的方法，在用户鉴权接口是能成功的，但在wlan密码认证接口里边是会导致认证失败的。</p>

<p>如果需要更多关于加密补齐的资料，可以参考<a href="http://www.di-mgt.com.au/cryptopad.html">Using Padding in Encryption</a></p>
]]></content>
  </entry>
  
</feed>
