<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 乱码 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/luan-ma/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2016-04-17T09:28:41+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[was中奇怪的生僻字乱码案例]]></title>
    <link href="http://mccxj.github.com/blog/20150808_ibm-jdk-char-encoding-diff.html"/>
    <updated>2015-08-08T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/ibm-jdk-char-encoding-diff</id>
    <content type="html"><![CDATA[<h2>问题描述</h2>

<p>这个今天早上提供的一个生产问题。大体是说，改资料的时候，有个客户的名字有生僻字，叫"刘",保存之后就乱码了，变成"刘?"</p>

<h2>分析过程</h2>

<p>乱码需要确认数据传输过程中编码方式。</p>

<ol>
<li>数据是通过jQuery的ajax过来的，并且没有提前处理数据(只有组装了一个js对象)，所以是采用encodeURIComponent进行处理的，对于中文可以很粗糙的理解成UTF-8编码过。这一点通过抓包工具是可以确认的。</li>
<li>到了服务端之后会通过getParameter获取参数，由于带charsetEncoding的过滤器，并且是采用UTF-8的，那么这里拿到的字符串应该也是不会乱码的。</li>
</ol>


<p>到了这里，代码并没有特别之处。按我的理解，只要字符集能够支持这个生僻字，就不会出现乱码。<br/>
难道保存到数据库的时候乱码了? 目前数据库是用GBK的，我去查了一下GBK的字符表，的确是有这么个字的。</p>

<p>我在本机上测了一下这个字的各种功能编码转换，都是正常的。<br/>
难道又是IBM的坑? 后来我又在服务器上测试了各种情况的输出，发现有另外一个字"䶮",除了字体大小有点不一样之外，几乎一模一样的。</p>

<p>下面整理了一个简单的测试程序，来说明这个奇怪的问题。</p>

<h2>测试结果</h2>

<p>首先要说明的是，这里有2个字,一小一大,还有它们对应的unicode和utf-8编码。<br/>
测试结果是采用secureCRT的GB18030编码显示。</p>

<p><code>text
有两个字:       小        大
unicode        \uE863    \u4dae
浏览器(utf-8)   %EE%A1%A3  %E4%B6%AE
</code></p>

<p>下面的测试代码，为了编译时不关心字符集，所以换成utf-8字节来生成字符串。
```java
public class Test {</p>

<pre><code>public static void main(String[] args) throws java.io.UnsupportedEncodingException {
    new Test().test();
}

public void test() throws java.io.UnsupportedEncodingException {
    byte[] bbs = {-18,-95,-93,-28,-74,-82};
    String x = new String(bbs, "utf-8");
    String utf8 = new String(x.getBytes("utf-8"), "iso-8859-1");
    //byte[] bs = utf8.getBytes("iso-8859-1");  //test case 1
    //byte[] bs = x.getBytes("GBK");  //test case 2
    for(byte b : bs){
        System.out.println(b);
    }
    System.out.println(x);
}
</code></pre>

<p>}
```</p>

<p>对于Test Case 1, 测试一下字符串是不是本来就乱了。测试结果显示，2个字都正常，要输出成GB18030才是可以的(secureCRT设置GB18030编码)。
```text</p>

<blockquote><p>/tools/jdk1.6.0_20/bin/java -Dfile.encoding=GBK Test
-18
-95
-93
-28
-74
-82
䶮?
/opt/IBM/WebSphere/AppServer/java/bin/java -Dfile.encoding=GBK Test
-18
-95
-93
-28
-74
-82
?䶮
```</p></blockquote>

<p>```text</p>

<blockquote><p>/opt/IBM/WebSphere/AppServer/java/bin/java -Dfile.encoding=GB18030 Test
-18
-95
-93
-28
-74
-82
䶮
/tools/jdk1.6.0_20/bin/java -Dfile.encoding=GB18030 Test
-18
-95
-93
-28
-74
-82
䶮
```</p></blockquote>

<p>对于Test Case 2，主要测试一下转换成GBK字节的情况,因为这是保存到数据库的必要转换。<br/>
测试结果显示，ibm的jdk下，第一个字会编程乱码(对应的是63)。
```text</p>

<blockquote><p>/tools/jdk1.6.0_20/bin/java -Ddefault.client.encoding=GBK -Dfile.encoding=GBK Test
-2
-97
63
?
/opt/IBM/WebSphere/AppServer/java/bin/java -Ddefault.client.encoding=GBK -Dfile.encoding=GBK Test
63
-2
-97
?
```</p></blockquote>

<h2>现象总结</h2>

<ol>
<li>在GBK字符表中，第一个字是存在的，第二个字不存在。在GB18030中两个都存在。从显示上，也证明了GBK和GB18030并不完全兼容。</li>
<li>IBM的jdk为找不到第一个字，但能找到第二个字。oracle的jdk刚好相反。</li>
<li>尝试使用百度拼音输入的时候，是可以找到2个字的。如下图的第2和第6个字。</li>
<li>客户需要的是小的字(第一个)，但使用IBM的jdk转换GBK是找不到这个字的，一定会乱码。</li>
<li>假设从前台输入的是第二个字，IBM的jdk应该是可以正常转换并得到的"正确"的字(正确的小字)，从而保证数据库不乱码。</li>
</ol>


<p><img src="/assets/images/2015/yan.png" alt="yan" /></p>

<p>规避方法，选择输入第二个字(大字，截图中的第二个字，应该看不出有什么区别)。话说回来，感觉这是ibm的jdk的bug，字符对应错了。</p>

<h2>相关资料</h2>

<ul>
<li><a href="https://github.com/willonboy/ChineseToPinYin">各种字符集编码表</a></li>
<li><a href="http://ff.163.com/newflyff/gbk-list/">GBK编码表</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java字符编码问题]]></title>
    <link href="http://mccxj.github.com/blog/20150114_java-charset-problem.html"/>
    <updated>2015-01-14T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/java-charset-problem</id>
    <content type="html"><![CDATA[<p>1.假设文件用UTF-8保存了中文"操作计算机"，然后使用GBK编码进行读取?
<code>java
String str = FileUtils.readFileToString(new File("/myfile"), "GBK");
System.out.println(str);
str = new String(str.getBytes("GBK"), "UTF-8");
System.out.println(str);
</code></p>

<p>可以发现，后续转成UTF-8仍然有部分乱码，如果保存的内容是"操作计算"就不会乱码。为什么?</p>

<p>2.继续上述问题，如果使用ISO-8859-1进行读取?
<code>java
String str = FileUtils.readFileToString(new File("/myfile"), "ISO-8859-1");
System.out.println(str);
str = new String(str.getBytes("ISO-8859-1"), "UTF-8");
System.out.println(str);
</code></p>

<p>可以发现，可以发现无论是"操作计算机"还是"操作计算"、"操 作计算"，都不会乱码。为什么?</p>

<p>3.如果文件采用GBK编码保存中文，但是使用UTF-8读取，就会发现怎么转都是乱码? 为什么?</p>

<p>4.假设代码如下，为什么前面3行都是输出乱码?
<code>java
System.out.println(new String("123你".getBytes("ISO-8859-1"), "ISO-8859-1"));
System.out.println(new String("123你".getBytes("ISO-8859-1"), "GBK"));
System.out.println(new String("123你".getBytes("ISO-8859-1"), "UTF-8"));
System.out.println(new String("123你".getBytes("GBK"), "GBK"));
System.out.println(new String("123你".getBytes("UTF-8"), "UTF-8"));
</code></p>

<p>5.请思考，下面的同样掺和了ISO-8859-1，为什么却能正常?
```java
System.out.println(new String(new String("123你".getBytes("GBK"), "ISO-8859-1")</p>

<pre><code>    .getBytes("ISO-8859-1"), "GBK"));
</code></pre>

<p>```</p>

<p>6.假设使用http发送xml，那么xml报文采用何种编码发送和xml的编码头部指定的编码有什么关系?
<code>java
&lt;?xml version="1.0" encoding="GBK" ?&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编码与乱码问题]]></title>
    <link href="http://mccxj.github.com/blog/20150107_charset-intro.html"/>
    <updated>2015-01-07T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/charset-intro</id>
    <content type="html"><![CDATA[<h2>关于java的编码</h2>

<ul>
<li>java的源代码编码格式和最终的运行是没什么关系的。你可以使用GBK或UTF-8来编程。</li>
<li>java编译后的class文件都是使用UTF-16来存储和运行的。</li>
<li>在eclipse中是根据文件设置字符编码来编译的，所以可以对不同文件使用有不同的编码，但这个不推荐。</li>
<li>使用javac编译可以通过-encoding指定字符编码,如果不指定，会使用系统默认编码，这个跟平台有关。所以使用ant需要指定编码。</li>
</ul>


<p>下面这种在ant中常见的警告，就是表示编译用的编码和编程的编码不一致。
<code>java
CCustGroupPrompt.java:43: 警告：编码 UTF-8 的不可映射字符
</code></p>

<p>更多java相关的，见<a href="20150114_java-charset-problem.html">java字符编码问题</a></p>

<h2>关于jsp的编码</h2>

<ul>
<li>jsp内容字符编码是pageEncoding指定的，用于指导jsp的编译器进行编译成java/class文件。如果没设置会采用contentType。</li>
<li>contentType是用于response的输出http报文时的编码，浏览器根据ContentType来采用何种字符编码显示。和使用response.setCharacterEncoding()是一个道理的。
<code>java
&lt;%@ page contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;
</code></li>
</ul>


<p>如果page设置的内容，和页面中的meta设置不一样，那又怎样?</p>

<ul>
<li>meta是用来设置当前网页后续处理的默认编码，和当前页面的响应无关。</li>
<li>只要page设置和jsp文件内容实际字符编码一致，就不会乱。</li>
</ul>


<p>如果不设置page，那又怎样?</p>

<ul>
<li>如果没有指定page的话， contentType默认是text/html，浏览器会根据meta指定的编码来解析报文。这个时候，如果jsp内容实际编码和meta指定的编码一样，就能够显示正常。</li>
<li>编译后的java文件内容，其实都是不能显示中文的。经测试，发现是用的ISO-8859-1读取的文件,并转换成UTF-8的java文件。</li>
<li>如果使用UTF-16来编写jsp，但是不指定page，编译后的java和class反编译都是能够显示中文的。并且在tomcat下(其他未测试)，即使meta设置的编码不一样，也能够显示中文，因为这个时候contentType变成text/html;charset=UTF-16BE，具体大家可以查看编译后的java文件。感觉在编译的时候能够优先识别到UTF-16一样。</li>
</ul>


<p>上述情况只是在tomcat上测试过，并不代表其他在中间件也是同样的情况，实际应用中应该确保jsp内容的字符编码、page设置、meta设置保持一致，避免一些灵异事件。</p>

<h2>关于URL的编码</h2>

<p>这里指直接通过URL传递中文，或者手工拼接中文到URL的情况，究竟使用何种编码传递没有规定，看浏览器心情，不具可移植性。
对于IE来说，虽然高级选项上有个发送UTF-8 URL，但不一定会勾上。如果真的要使用，应该自行编码后传递。</p>

<h2>普通表单提交</h2>

<p>使用GET或者POST，对于编码来说，没有区别。
都会对中文进行编码，编码采用页面的字符编码。</p>

<p>例如"中文"的UTF-8编码是E4B8ADE69687，传递的内容就是%E4%B8%AD%E6%96%87。</p>

<p>页面编码是通过<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">指定的。
而html5页面可以通过<meta charset="utf-8">这种简化形式指定。</p>

<h2>表单文件上传</h2>

<p>需要使用POST，并在form中增加属性enctype="multipart/form-data"。
不会对文件名、输入框内容进行字符编码。
采用页面的字符编码，对内容原样传输。</p>

<p>区别可能不是很好理解，下面举例：
例如"中文"的UTF-8编码是E4B8ADE69687，传递的内容是字节E4B8ADE69687，或许在某些工具上可以直接看到“中文”.(像fiddler用utf-8来显示的)</p>

<h2>Java/Servlet/Struts2(commons-upload)对参数的处理</h2>

<p>Java/Servlet对参数的处理
* 默认只能获取到普通表单的参数提交。
* 编码格式通过request.setCharacterEncoding("UTF-8")指定，这个已经有过滤器可以实现的了。
* 使用Struts2的话，对multipart/form-data的提交也是能够获取通过getParameter取到参数的。</p>

<p>注意的是，有些实现(如tomcat)，对参数的解析是延后处理的，设置了编码之后，获取一个参数(这个时候参数全部都解析了)，再设置编码是没有效果。ServletRequest的setCharacterEncoding描述也是这么说的。</p>

<p>标准的commons-upload，文件名的获取、输入框内容的获取使用的编码可能不一样。
* 文件名的获取，就是FileItem.getName(),解析编码需要通过ServletFileUpload#setHeaderEncoding这个方法设置，如果没有设置，采用平台编码(可以通过-Dfile.encoding=UTF-8来指定，否则win通常是ANSI(GBK),unix看locale)
* 输入框内容，就是FileItem.getString(),可以指定解析编码，如果不指定采用ISO-8859-1。</p>

<p>Struts2默认使用commons-upload进行文件上传的处理。
* 对于文件名的获取没有通过setHeaderEncoding设置，所以这个通常会依赖于平台编码(需要确保平台编码和页面编码一致)
* 对于输入框内容的获取，指定了编码格式为request.getCharacterEncoding()，否则采用默认的ISO-8859-1。所以这个需要提前设置一下CharacterEncoding，否则也可能会乱码。</p>
]]></content>
  </entry>
  
</feed>
