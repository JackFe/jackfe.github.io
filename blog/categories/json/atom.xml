<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: json | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/json/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2016-04-18T23:04:35+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用net.sf.json库进行json反序列化时存在的问题]]></title>
    <link href="http://mccxj.github.com/blog/20150108_net-sf-json-problem.html"/>
    <updated>2015-01-08T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/net-sf-json-problem</id>
    <content type="html"><![CDATA[<h3>问题描述</h3>

<p>```java
String content = "{\"response_head\":{\"menuid\":\"xxx\",\"process_code\":\"xxx\",\"verify_code\":\"\",\"resp_time\":\"20150107103234\",\"sequence\":{\"resp_seq\":\"20150107103301\",\"operation_seq\":\"\"},\"retinfo\":{\"retcode\":\"120\",\"rettype\":\"0\",\"retmsg\":\"[182096|]处理失败,原因:[屏蔽具体的失败原因！]\"}},\"response_body\":{} }";
JSONObject object = JSONObject.fromObject(content);
System.out.println(object.toString());</p>

<p>/<em>
{"response_head":{"menuid":"xxx","process_code":"xxx","verify_code":"","resp_time":"20150107103234","sequence":{"resp_seq":"20150107103301","operation_seq":""},"retinfo":{"retcode":"120","rettype":"0","retmsg":["182096|"]}},"response_body":{}}
</em>/
```</p>

<h3>问题分析</h3>

<p>采用json-lib-2.4-jdk15.jar，测试代码如上，会发现retmsg的值变成"[182096|".</p>

<p>测试简化json字符串，最终效果如下：</p>

<p>解析失败的例子：
<code>json
"{\"response_head\":{\"retmsg\":\"[182096|]处理失败,原因:[屏蔽具体的失败原因！]\"}}"
</code></p>

<p>继续简化的话，就会解析成功
<code>json
"{\"response_head\":\"[182096|]处理失败,原因:[屏蔽具体的失败原因！]\"}"
</code></p>

<p>找了一下源码，发现json-lib在某些情况下(绕来绕去，断点发现的)会尝试解析字符串，看看是不是json对象。（尼玛，太智能了）</p>

<p>AbstractJSON.java中的260行,这个时候str是后面的内容。
```java</p>

<pre><code>     } else if( JSONUtils.mayBeJSON( str ) ) {
        try {
           return JSONSerializer.toJSON( str, jsonConfig );
        } catch( JSONException jsone ) {
           return str;
        }
     }
</code></pre>

<p>```</p>

<p>JsonArray.java中的1130行，这个时候v已经是"182096|"。这个时候会判断v是不是一个json对象，如果搞一个数组回去，否则就是搞一个字符串(上述现象)。
```java</p>

<pre><code>           tokener.back();
           Object v = tokener.nextValue( jsonConfig );
           if( !JSONUtils.isFunctionHeader( v ) ){
              if( v instanceof String &amp;&amp; JSONUtils.mayBeJSON( (String) v ) ){
                 jsonArray.addValue( JSONUtils.DOUBLE_QUOTE + v + JSONUtils.DOUBLE_QUOTE,
                       jsonConfig );
              }else{
                 jsonArray.addValue( v, jsonConfig );
              }
              fireElementAddedEvent( index, jsonArray.get( index++ ), jsonConfig );
           }
</code></pre>

<p>```</p>

<p>例如，下面的情况会产生一个数组：
```json
"{\"response_head\":{\"retmsg\":\"[{1820: 96|}]处理失败,原因:[屏蔽具体的失败原因！]\"}}"</p>

<p>{"response_head":{"retmsg":[{"1820":"96|"}]}}
```</p>

<p>关于如何判断是否是json,是会判断以[开头，以]结束的，刚好中枪。而尝试去截取中间内容的时候，又碰巧遇到中间的]字符，所以生成的字符串就是被截断了一部分的。
```java  <br/>
   /**</p>

<pre><code>* Tests if the String possibly represents a valid JSON String.&lt;br&gt;
* Valid JSON strings are:
* &lt;ul&gt;
* &lt;li&gt;"null"&lt;/li&gt;
* &lt;li&gt;starts with "[" and ends with "]"&lt;/li&gt;
* &lt;li&gt;starts with "{" and ends with "}"&lt;/li&gt;
* &lt;/ul&gt;
*/
</code></pre>

<p>   public static boolean mayBeJSON( String string ) {</p>

<pre><code>  return string != null
        &amp;&amp; ("null".equals( string )
              || (string.startsWith( "[" ) &amp;&amp; string.endsWith( "]" )) || (string.startsWith( "{" ) &amp;&amp; string.endsWith( "}" )));
</code></pre>

<p>   }
```</p>

<h3>问题结论</h3>

<ul>
<li>当json对象中某个值是以"{"开头，"}"结束，或者"["开头,"]"结束的时候，解析结果可能不是期望的。</li>
<li>不幸的是，目前来看，这个问题是无解的，考虑使用其他json库吧。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用org.json库进行xml和json转换存在的问题]]></title>
    <link href="http://mccxj.github.com/blog/20141126_org-json-and-xml.html"/>
    <updated>2014-11-26T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/org-json-and-xml</id>
    <content type="html"><![CDATA[<p>org.json库中提供一个xml和json进行转换的工具类，XML.java</p>

<p>使用方式如下：
* xmlstr = XML.toString(jsonstr)
* jsonstr = XML.toJSONObject(xmlstr).toString()</p>

<p>中间层原有代码使用这种方式进行格式转换，不过存在一些问题：
* json转换为xml的时候，对带content字段的节点，是直接生成文本，而不是<content>xx</content>
* xml转换为json的时候，会对指为整形(还有true/false/null等)的字符串尝试进行转换，变成原生类型</p>

<p>为了避免这两个问题，对org.json库的XML.java进行了一些修改:
* 去掉content字段的特殊处理
* 去掉整形字符串尝试转换的逻辑</p>

<p>见https://github.com/mccxj/JSON-java</p>

<p>经验教训: 以后引用第三方库的时候，要小心呀，避免触碰到一些特殊开关。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[json格式须知]]></title>
    <link href="http://mccxj.github.com/blog/20140815_json-intro.html"/>
    <updated>2014-08-15T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/json-intro</id>
    <content type="html"><![CDATA[<p>着重介绍与项目使用相关的json知识。如果没有特别说明，环境是指Javascript下的json。</p>

<h3>区分类型</h3>

<ul>
<li>首先需要区分json字符串和json对象，不过通常根据上下文可以区分。</li>
<li>协议关注的是json字符串，而代码中处理的是json对象，两者通过序列化(JSON.stringify)和反序列化相互转换(JSON.parse)。</li>
</ul>


<h3>常见格式</h3>

<ul>
<li>主要有数组和key/value形式的object</li>
<li>数组是有顺序的，可以不同类型，常用于顺序遍历操作。</li>
<li>object是无顺序的，key只能是字符串，常用于快速随机查找。</li>
<li>null是可以被序列化的，而undefined不可以(会消失)。</li>
<li>其他的一些特殊值，如Nan，Infinity，会被序列化为null。</li>
</ul>


<h3>关于数组</h3>

<ul>
<li>对于数组对象，虽然支持key/value的操作，但是序列化的时候设置的值会丢失。</li>
<li>数组序列化的长度是根据length属性来的，没有赋值的位置是null。</li>
<li>对数组遍历不应该采用for in语句，因为通过key/value设置的值也会被输出。</li>
</ul>


<h3>关于Object</h3>

<ul>
<li>规范上规定key是带双引号的字符串()，但实际上很多反序列化工具能够支持数值、单引号字符串、字符串字面量(没有引号的字符串)。</li>
<li>如果是一普通浮点数值，可以通过相应的数值作为key获取，或者通过对应的字符串来获取。如用2.2的话，可以用2.2或"2.2"。</li>
<li>如果是一整型数值，可以用数值，但用字符串只能用整型的，如用2.0的话，可以用2.0或2或"2",但"2.0"就不可以。</li>
<li>如果使用字符串字面量的话，需要避免一些关键字使用。如delete</li>
<li>key不应该重复，如果重复的话，通常结果是后面的会覆盖前面的。</li>
<li>可以用.后面加key来取值，或者用[]这样的操作符来获取，第一种方式更推荐，但只能支持非数字开头的字符串，unicode也是可以。</li>
<li>对object遍历可以采用for in语句。</li>
</ul>


<h3>协议转换</h3>

<ul>
<li>协议传输的是json字符串，但通常里边的类型都是字符串，不区分数值，因此做数值运算需要先转换。</li>
<li>和xml一样，需要注意特殊字符如引号、回车、unicode等，尽量避免手动拼接，采用序列化工具。</li>
<li>object类型的json序列化/序列化的时候，都不应该预期他是有顺序的，虽然很多库都有带默认顺序，应该使用数组。</li>
</ul>

]]></content>
  </entry>
  
</feed>
