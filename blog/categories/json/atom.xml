<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: json | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/json/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2015-01-13T21:22:15+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用net.sf.json库进行json反序列化时存在的问题]]></title>
    <link href="http://mccxj.github.com/blog/20150108_net-sf-json-problem.html"/>
    <updated>2015-01-08T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/net-sf-json-problem</id>
    <content type="html"><![CDATA[<h3>问题描述</h3>

<p>```java
String content = "{\"response_head\":{\"menuid\":\"xxx\",\"process_code\":\"xxx\",\"verify_code\":\"\",\"resp_time\":\"20150107103234\",\"sequence\":{\"resp_seq\":\"20150107103301\",\"operation_seq\":\"\"},\"retinfo\":{\"retcode\":\"120\",\"rettype\":\"0\",\"retmsg\":\"[182096|]处理失败,原因:[屏蔽具体的失败原因！]\"}},\"response_body\":{} }";
JSONObject object = JSONObject.fromObject(content);
System.out.println(object.toString());</p>

<p>/<em>
{"response_head":{"menuid":"xxx","process_code":"xxx","verify_code":"","resp_time":"20150107103234","sequence":{"resp_seq":"20150107103301","operation_seq":""},"retinfo":{"retcode":"120","rettype":"0","retmsg":["182096|"]}},"response_body":{}}
</em>/
```</p>

<h3>问题分析</h3>

<p>采用json-lib-2.4-jdk15.jar，测试代码如上，会发现retmsg的值变成"[182096|".</p>

<p>测试简化json字符串，最终效果如下：</p>

<p>解析失败的例子：
<code>json
"{\"response_head\":{\"retmsg\":\"[182096|]处理失败,原因:[屏蔽具体的失败原因！]\"}}"
</code></p>

<p>继续简化的话，就会解析成功
<code>json
"{\"response_head\":\"[182096|]处理失败,原因:[屏蔽具体的失败原因！]\"}"
</code></p>

<p>找了一下源码，发现json-lib在某些情况下(绕来绕去，断点发现的)会尝试解析字符串，看看是不是json对象。（尼玛，太智能了）</p>

<p>AbstractJSON.java中的260行,这个时候str是后面的内容。
```java</p>

<pre><code>     } else if( JSONUtils.mayBeJSON( str ) ) {
        try {
           return JSONSerializer.toJSON( str, jsonConfig );
        } catch( JSONException jsone ) {
           return str;
        }
     }
</code></pre>

<p>```</p>

<p>JsonArray.java中的1130行，这个时候v已经是"182096|"。这个时候会判断v是不是一个json对象，如果搞一个数组回去，否则就是搞一个字符串(上述现象)。
```java</p>

<pre><code>           tokener.back();
           Object v = tokener.nextValue( jsonConfig );
           if( !JSONUtils.isFunctionHeader( v ) ){
              if( v instanceof String &amp;&amp; JSONUtils.mayBeJSON( (String) v ) ){
                 jsonArray.addValue( JSONUtils.DOUBLE_QUOTE + v + JSONUtils.DOUBLE_QUOTE,
                       jsonConfig );
              }else{
                 jsonArray.addValue( v, jsonConfig );
              }
              fireElementAddedEvent( index, jsonArray.get( index++ ), jsonConfig );
           }
</code></pre>

<p>```</p>

<p>例如，下面的情况会产生一个数组：
```json
"{\"response_head\":{\"retmsg\":\"[{1820: 96|}]处理失败,原因:[屏蔽具体的失败原因！]\"}}"</p>

<p>{"response_head":{"retmsg":[{"1820":"96|"}]}}
```</p>

<p>关于如何判断是否是json,是会判断以[开头，以]结束的，刚好中枪。而尝试去截取中间内容的时候，又碰巧遇到中间的]字符，所以生成的字符串就是被截断了一部分的。
```java  <br/>
   /**</p>

<pre><code>* Tests if the String possibly represents a valid JSON String.&lt;br&gt;
* Valid JSON strings are:
* &lt;ul&gt;
* &lt;li&gt;"null"&lt;/li&gt;
* &lt;li&gt;starts with "[" and ends with "]"&lt;/li&gt;
* &lt;li&gt;starts with "{" and ends with "}"&lt;/li&gt;
* &lt;/ul&gt;
*/
</code></pre>

<p>   public static boolean mayBeJSON( String string ) {</p>

<pre><code>  return string != null
        &amp;&amp; ("null".equals( string )
              || (string.startsWith( "[" ) &amp;&amp; string.endsWith( "]" )) || (string.startsWith( "{" ) &amp;&amp; string.endsWith( "}" )));
</code></pre>

<p>   }
```</p>

<h3>问题结论</h3>

<ul>
<li>当json对象中某个值是以"{"开头，"}"结束，或者"["开头,"]"结束的时候，解析结果可能不是期望的。</li>
<li>不幸的是，目前来看，这个问题是无解的，考虑使用其他json库吧。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用org.json库进行xml和json转换存在的问题]]></title>
    <link href="http://mccxj.github.com/blog/20141126_org-json-and-xml.html"/>
    <updated>2014-11-26T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/org-json-and-xml</id>
    <content type="html"><![CDATA[<p>org.json库中提供一个xml和json进行转换的工具类，XML.java</p>

<p>使用方式如下：
* xmlstr = XML.toString(jsonstr)
* jsonstr = XML.toJSONObject(xmlstr).toString()</p>

<p>中间层原有代码使用这种方式进行格式转换，不过存在一些问题：
* json转换为xml的时候，对带content字段的节点，是直接生成文本，而不是<content>xx</content>
* xml转换为json的时候，会对指为整形(还有true/false/null等)的字符串尝试进行转换，变成原生类型</p>

<p>为了避免这两个问题，对org.json库的XML.java进行了一些修改:
* 去掉content字段的特殊处理
* 去掉整形字符串尝试转换的逻辑</p>

<p>见https://github.com/mccxj/JSON-java</p>

<p>经验教训: 以后引用第三方库的时候，要小心呀，避免触碰到一些特殊开关。</p>
]]></content>
  </entry>
  
</feed>
