<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 源码 | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/yuan-ma/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2016-04-18T23:04:35+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从commons-dbcp源码学习设计思路]]></title>
    <link href="http://mccxj.github.com/blog/20151226_commons-dbcp-source-view.html"/>
    <updated>2015-12-26T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/commons-dbcp-source-view</id>
    <content type="html"><![CDATA[<p>由于整个连接池的性能是由commons-pool决定的，有空再讲解一下commons-pool的实现，特别是1.x和2.x的区别。<br/>
此次分析的是commons-dbcp 1.x源码，对应commons-pool 1.x版本。</p>

<h3>commons-dbcp怎样与commons-pool集成?</h3>

<p><p><img src='/uml/f702257257e2a76c467e9deefa9aba02.png'
        alt='PlantUML diagram' class='plantuml'/></p></p>

<p>如上图所示，集成commons-dbcp的时候采用BasicDataSource这个实现类，它的实际功能是交给PoolingDataSource的(内部是通过commons-pool来管理连接对象)。<br/>
不过,我不是很理解为什么要这么设计?</p>

<h3>commons-dbcp的连接有什么特别?</h3>

<p><p><img src='/uml/49272355ea02549d9d583580c61f2fbd.png'
        alt='PlantUML diagram' class='plantuml'/></p></p>

<p>连接这种对象有点特殊的，所以commons-dbcp提供了一些connection方面的增强特性。例如:</p>

<ul>
<li>PoolGuardConnectionWrapper是最终客户端拿到的对象，能够防止多次关闭等误操作</li>
<li>PoolableConnection是PoolGuardConnectionWrapper内部的对象，可以结合pool进行管理，最大的优势就是可以保留客户端代码无需任何改动。<strong>实际上，很多自带生命周期api的对象，一旦池化之后都会考虑这么设计。</strong></li>
<li>PoolingConnection是开启statement pool的时候PoolableConnection的内部对象，内部采用一个KeyedObjectPool进行管理(key主要是通过执行的sql语句来生成的)。不过这种对象一般不需要池化</li>
</ul>


<h3>如何优化Connection、Statement、ResultSet的生命周期管理?</h3>

<p>jdbc的api有个非常烦人的地方，就是每个Connection、Statement、ResultSet对象都是需要关闭。所以写起来代码繁琐的，很多人就跳过这些健壮性代码。<br/>
我研究了一下dbcp的实现，发现它能够发现未关闭的Statement、ResultSet对象，并在适当的时候进行关闭。</p>

<p><p><img src='/uml/9e68d18ad3c606c559685e1421abc86b.png'
        alt='PlantUML diagram' class='plantuml'/></p></p>

<p>具体实现思路是这样的:</p>

<ul>
<li>需要实现生命周期管理的对象需要继承AbandonedTrace，这包括了DelegatingStatement、DelegatingResultSet、DelegatingConnection等</li>
<li>通过DelegatingConnection生成的statement、resultset等都是带Delegating的，也就是带trace特性的。</li>
<li>对于上图，有个特别的是DelegatingConnection的trace可能包括ResultSet，这个主要由DelegatingDatabaseMetaData产生的。因为metadata的查询不需要先有statement。</li>
<li>处理流程调用connection.close(), 会返回到池中(见PoolableConnection)， 触发PoolableConnectionFactory的passivateObject(commons-pool的内置回调)，最后触发DelegatingConnection的passivate，在这里会递归检查所有的trace。</li>
<li>注意的是，DelegatingConnection的close方法除了触发trace对象的关闭，还会关闭底层的连接对象。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android-Universal-Image-Loader源码快扫]]></title>
    <link href="http://mccxj.github.com/blog/20150624_Android-Universal-Image-Loader-source-view.html"/>
    <updated>2015-06-24T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/Android-Universal-Image-Loader-source-view</id>
    <content type="html"><![CDATA[<h2>ImageLoaderConfiguration/ImageLoaderConfiguration.Builder学习</h2>

<p>构造复杂对象的方式: Builder模式,用来创建ImageLoaderConfiguration对象,适用于链式写法。</p>

<p>常见结构如下：<strong>关键点: 私有构造(拷贝而非应用，避免build复写)、内部类(影响局部化,内聚好)、返回this(支持链式)</strong>
```java
class A {
  private A(Builder builder) {</p>

<pre><code>// create A with builder's copy
</code></pre>

<p>  }</p>

<p>  public static class Builder{</p>

<pre><code> Builder buildStep1(){
    //...
    return this;
 }

 Builder buildStep2(){
    //...
    return this;
 }   

 A build() {
    return new A(this);
 }  
</code></pre>

<p>  }
}
```</p>

<h2>ImageLoaderConfiguration支持的特性</h2>

<p><code>
-- 源码没什么养分，关注特性是如何表现在内部结构上。
-- 类层次的结构，能体会就体会，不体会就拉到。层次是渐进实现的，不能体会也没什么。
-- 如果有机会的话，可以在实践项目中调试进去学学。
</code></p>

<p>如果想学习相关特性是怎么实现的，可以根据配置的去反推实现代码(搜索或调用关系):
```
基本特性（可配置）:
  基本控制:</p>

<pre><code>线程池大小 -- 不能太多
线程优先级 -- 略低
请求任务排队  -- 默认FIFO
是否开启调试日志 -- DEBUG log
</code></pre>

<p>  多级缓存特性:</p>

<pre><code>内存缓存大小
硬盘缓存大小，文件数量限制，文件名生成规则
-- 关联硬盘图片处理器BitmapProcessor
</code></pre>

<p>  图片专用:</p>

<pre><code>缓存图最大宽高 --- 用于约束图片大小
显示图的约束
-- 关联下载器ImageDownloader(还通过networkDeniedDownloader/slowNetworkDownloader区分不同情况，这不就是Null Object模式么?)
-- 关联解码器ImageDecoder
</code></pre>

<p>```</p>

<h2>关于ImageLoader如何解决错乱问题</h2>

<p>ImageLoader就是一个singleton实现，配合init+ImageLoaderConfiguration进行初始化，没什么说的。很常见的设计实现。</p>

<p>大多是helper method 关注displayImage/loadImage最终实现即可。这也是常见做法，便于使用。</p>

<p>问题: url -- 关联的view，问题在于url请求是异步的，而view可能被重复利用。<br/>
这里用的ImageAware，看他们的实现类，有个ViewAware，就是一个view的包装，我想说的是WeakReference在android中很常用呀。 -- 这句是废话</p>

<p><code>
使用ImageAware占位
  图片宽高
  实际的View --可重用
  id -- 尼玛，这是解决问题的关键
</code></p>

<p>见DisplayBitmapTask有个isViewWasReused倒出重点，从它的实现就可以判断完整的算法拉。</p>

<p>内部结构 cacheKeysForImageAwares map&lt;ImageAware.id, memorycachekey(由URI + 宽高生成)></p>

<p>不过ViewAware的id是用view的hashcode来指定的， NonViewAware的id是用url来指定的。<br/>
so， listview的时候，使用loadImage是可以避免错乱的，而用displayImage就呵呵拉。<br/>
判断方式如下：根据id可以找到目前的url和当前的url比较即可。知道是不是被复用了。</p>

<p>相对于原理上的image#setTag(url)然后比较的方式，更加透明，侵入性少。</p>

<h2>再看看ImageLoaderEngine在任务管理、线程方面的处理</h2>

<p>原以为这货应该比较好处理，图样图森破呀，毕竟它支持多种状态(暂停，恢复，关闭等)</p>

<p>先说一下几个AtomicBoolean的变量，主要就是判断状态的boolean拉，当然这货是线程安全的，其实用boolean也行，毕竟也是原子的(注意可见性问题即可)
```</p>

<pre><code>private final AtomicBoolean paused = new AtomicBoolean(false);
private final AtomicBoolean networkDenied = new AtomicBoolean(false);
private final AtomicBoolean slowNetwork = new AtomicBoolean(false);`
</code></pre>

<p>```</p>

<p>另外，还有3个线程执行器，简单看看用途。至于为什么要这么多个，哥认为是这样的：</p>

<ul>
<li>在loader中走进displayImage之后，它重要检查一下内存中有木有(耗时小，无需线程)。</li>
<li>如果没有才会扔给engine，engine首先检查一下硬盘上有木有(有io，所以走taskDistributor)。</li>
<li>如果硬盘上有，走taskExecutorForCachedImages(同理有io)</li>
<li>还是没有，走其他(maybe网络io)</li>
<li>在请求较多，兼顾命中、不命中的情况，它选择了采用多级的Executor</li>
</ul>


<p>```</p>

<pre><code>private Executor taskExecutor; -- 木有在disk的情况，一般走网络
private Executor taskExecutorForCachedImages; -- 在disk的情况
private Executor taskDistributor;  -- 根据情况分发给上面2个
</code></pre>

<p>```</p>

<p>还有2个map，第一个就是用来保存id和图片url的对应关系(简单是这么理解)<br/>
另外是用来控制不同view但有相同uri的并发请求。
```</p>

<pre><code>private final Map&lt;Integer, String&gt; cacheKeysForImageAwares = Collections
        .synchronizedMap(new HashMap&lt;Integer, String&gt;());
private final Map&lt;String, ReentrantLock&gt; uriLocks = new WeakHashMap&lt;String, ReentrantLock&gt;();
</code></pre>

<p>```</p>

<p>不熟悉ReentrantLock的童鞋可参考 https://www.ibm.com/developerworks/cn/java/j-jtp10264/</p>

<p>LoadAndDisplayImageTask通过控制相同的uri持有同一个锁，这样执行的时候，后面的就会等待。<br/>
具体可以参考LoadAndDisplayImageTask的实现，不过用ReentrantLock需要特别注意写法，避免死锁。<br/>
不过我认为getLockForUri并没有同步，还是有存在相同url获取到不同lock的可能，不过这不影响功能，而且受限于并发大小也很难出现。</p>

<h2>关于url的中文</h2>

<p>网上有看到一些人说中文图片名会出错，可能是很久之前的版本吧。我这里要说的是，我认为这是个简单的问题，即使改源码也很容易处理。<br/>
不过即使源码有相关处理，通常也不会关注的，不过今天刚好有人问我一个中文路径的问题，所以我就关注了一下它怎么实现的。</p>

<p>首先看BaseImageDownloader是如何请求中文图片的。由于http只是支持ascii的url编码，所以必须要编码的，通常用utf-8,虽然这个没规定。貌似我们的基线没有考虑这个问题，应该是没有掉过坑。
```</p>

<pre><code>protected HttpURLConnection createConnection(String url, Object extra) throws IOException {
    String encodedUrl = Uri.encode(url, ALLOWED_URI_CHARS);
    HttpURLConnection conn = (HttpURLConnection) new URL(encodedUrl).openConnection();
    conn.setConnectTimeout(connectTimeout);
    conn.setReadTimeout(readTimeout);
    return conn;
}
</code></pre>

<p>```</p>

<p>另外，还有一个容易出现中文问题的就是保存到硬盘的情况(android貌似不是什么大问题，如果是做server开发的话，就得特别注意)<br/>
带的实现有HashCodeFileNameGenerator(默认)和Md5FileNameGenerator，这2种处理都不会产生中文问题。<br/>
不过我建议还是用Md5FileNameGenerator，hashcode做唯一性并不是很靠谱，如果是大量的固定文件名长度的图片，还是很容易冲突的。</p>

<h2>小结</h2>

<p>源码何其多，带着问题学习效果更好。挑几个疑惑看看别人怎么处理就是收获。  <br/>
从类的层次着手是很困难的，特别是大型源码。了解上层架构，学示例，然后调调源码或许更好。
大多数情况，相对于细节，应该更关注关键数据的结构、如何组织数据的结构来解决问题。<br/>
如果自己设计，应该考虑的重要问题有: 如何使用? 用怎样的结构表示数据和状态? <br/>
XX设计模式不要硬套，从过程式演变出来更加自然(经验性的除外)。推荐重构与模式。<br/>
大而全的源码解读没有什么用，带问题分析的更有价值。<br/>
学好基础，模仿起来也不容易掉坑。</p>

<p>-- 以上纯属肉眼分辨，并无调试过，不做正确性验证，仅供参考。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小毛的jforum2源码分析(旧)]]></title>
    <link href="http://mccxj.github.com/blog/20120903_jforum2-source-analytics.html"/>
    <updated>2012-09-03T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/jforum2-source-analytics</id>
    <content type="html"><![CDATA[<p>这个文章大约是08年的时候写的了，jforum是java中还算比较有名的开源论坛系统，我上一家公司拿它来做二次开发。jforum2是内部自己实现的mvc，到了jforum3的时候全部重写了，都使用开源框架来做，现在不知发展到什么情况了。所以，这里特指jforum2.</p>

<h2>正文</h2>

<p>怎么才算好的源码分析呢？当然我这个肯定不算。我想大概分为几个层面吧，写写注释那算最基本的了，
写写要点思路和难点，算是还不错拉，再难的就是跳出源码举一反三，形成自己的一套思路吧。好好努力吧。</p>

<p>这次针对的是jforum2.1.8,大概jforum团队已经没心情理这个版本了，都冲着jforum3去了。选择这个版本，
主要是因为jforum在java论坛类应用中算是佼佼者了，很多人都拿这个来做二次开发，而jforum3使用的是另外一套架构了，
而且还没完全release，所以斟酌一下，还是选择这个经典的版本。</p>

<p>关于jforum的介绍网上已经很多了，这里也简单抄录一段：JForum 是一个功能强大 ，易于管理的论坛。
它的设计完全遵从MVC设计模式，能够在任何Servlet容器与EJB服务器上运行。而且可以轻松的定制与扩展JForum论坛。
上面这段简述还是中肯的。另外，jforum是模仿phpbb写的，使用的是classic-blue风格，但不能自己选择风格，要的话只能自己修改了。
再说几句，说jforum比较优秀是因为java开源的论坛系列精品少，而且jforum的bug也真的不少，不信试试就知道了。
不过作为一个成型的组件，功能强大并且适合二次开发，还是应该列入考虑范围的。</p>

<p>不管怎样，jforum是个不错的学习范本，至少让你觉得写个山寨框架不是什么难事，
而事实也的确是这样的。重要的一点是，不要轻易拿出来害人就是了：)这里先列举出可能一些分析点：</p>

<p>● web.xml<br/>
● 初始化流程<br/>
● 处理请求流程(mvc)<br/>
● 文件监控<br/>
● 缓存实现<br/>
● 数据库访问实现<br/>
● 权限控制</p>

<p>首先了解一个web应用，首要的就是知道处理流程。首先来看看入口web.xml，里边的内容还是挺清晰的，
可以看到里边有个监听器ForumSessionListener，*.page的过滤器ClickstreamFilter，还有2个*.page的处理器，
其中InstallServlet是安装相关的，JForum则是前端处理器。</p>

<p>基本上<strong>整个流程</strong>就是</p>

<pre><code>client request -&gt; ForumSessionListener -&gt; ClickstreamFilter -&gt; JForum -&gt; server response.
</code></pre>

<p>ForumSessionListener实现了HttpSessionListener接口，但是只是对session destory做了处理，
在这个过程中，保存session的历史记录到DB，并清除用户信息和相关的security信息。
ClickstreamFilter实现了Filter接口，主要的任务就交给BotChecker了，是用来检测client是不是一个robot来的。
主要的工作还是在JForum上面，不过先来看看jforum是怎么检测robot的？</p>

<p>BotChecker只有一个静态工具方法isBot，首先是检测是否请求robot.txt(这是标准的robot协议文件),
接下去判断User－Agent头部，最后是判断remotehost。而已知的robot都是写在文件clickstream-jforum.xml
里边的(包括agent和host)，并通过ConfigLoader加载进来的(SAX方式)。</p>

<p>可以看到JForum和InstallServlet都继承了JForumBaseServlet这个HttpServlet，而JForumBaseServlet包括2个重要的方法init和startApplication。众所周知，init是servlet初始化时调用的方法，JForumBaseServlet里边的init方法的流程是：</p>

<pre><code>调用父类的init(正常情况这是必须调用的)  -&gt; 配置log4j -&gt; startSystemglobals(加载全局参数配置SystemGlobals.properties -&gt; 加载数据库配置database.driver.config(如mysql就是WEB-INF/config/database/mysql/mysql.properties)  -&gt; 加载自定义配置(默认的是jforum-custom.conf)) -&gt; 配置缓存引擎 -&gt; 配置freemarker模板引擎 -&gt; 加载模块配置modulesMapping.properties -&gt; 加载url映射配置urlPattern.properties -&gt; 加载I18n配置(languages/*) -&gt; 加载页面映射配置(templatesMapping.properties) -&gt; 加载BBcode配置bb_config.xml -&gt; 结束
</code></pre>

<p>jforum实现了自己的mvc，整个mvc的脉络就是</p>

<pre><code>client request -&gt; 解析url(urlPattern.properties),获取module/action/param -&gt; 通过module获取相应的module class，并通过action识别并调用相应的方法(modulesMapping.properties) -&gt; 使用dao完成业务逻辑 -&gt; 调用template进行渲染(templatesMapping.properties)
</code></pre>

<p>其实整个mvc和struts没什么两样的，具体的流程以后再提。</p>

<p>JForumBaseServlet里边的startApplication方法的流程是：</p>

<pre><code>加载通用sql文件sql.queries.driver(就是/database/generic/generic_queries.sql) -&gt; 加载特定sql文件(如mysql就是/database/mysql/mysql.sql) -&gt; 加载Quartz定时任务配置 -&gt; 加载登录验证器(验证方式) -&gt; 加载Dao实现方式 -&gt; 加载文件修改监听器 -&gt; 加载查询索引管理器 -&gt; 加载定时统计任务
</code></pre>

<p>jforum实现了自己的orm，当然不是hibernate那种，是类似ibatis的那种sql mapping，并提供了多套的sql文件来实现数据库无关的特性，
整个流程也是比较清晰的:</p>

<pre><code>加载数据库配置 -&gt; 加载sql mapping file -&gt; 设置DAO实现 -&gt; 通过named sql找到对应的sql(在*.sql里边对应着) -&gt; 运行出数据
</code></pre>

<p>继续重点。JForum的init流程如下：</p>

<pre><code>JForumBaseServlet.init -&gt; JForumBaseServlet.startApplication -&gt; 启动数据库 -&gt; 预加载一些数据到缓存中(ForumRepository[Categories,Forums,同时在线最大人数，最后登录用户，注册用户数等等],用户等级,表情数据，屏蔽列表) -&gt; 结束
</code></pre>

<p>上面简单提到了<strong>Jforum处理请求的过程</strong>，现在在来看看这个过程，就是service方法，这次采用代码概要的方式展示：
<div class="highlight"><pre><code class="java"> <span class="c1">// 初始化JForumExecutionContext</span>
<span class="n">JForumExecutionContext</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="c1">// 包装request和response</span>
<span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WebRequestContext</span><span class="o">(</span><span class="n">req</span><span class="o">);</span>
<span class="n">response</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WebResponseContext</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
<span class="c1">// 检查数据库状态</span>
<span class="k">this</span><span class="o">.</span><span class="na">checkDatabaseStatus</span><span class="o">();</span>
<span class="c1">// 创建JForumContext并设置到JForumExecutionContext中去</span>
<span class="o">.......</span>
<span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
<span class="c1">// 刷新session         &lt;br/&gt;</span>
<span class="n">utils</span><span class="o">.</span><span class="na">refreshSession</span><span class="o">();</span>
<span class="c1">// 加载用户权限       &lt;br/&gt;</span>
<span class="n">SecurityRepository</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">SessionFacade</span><span class="o">.</span><span class="na">getUserSession</span><span class="o">().</span><span class="na">getUserId</span><span class="o">());</span>
<span class="c1">// 预加载模板需要的上下文</span>
<span class="n">utils</span><span class="o">.</span><span class="na">prepareTemplateContext</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">forumContext</span><span class="o">);</span>
<span class="c1">// 从request中解析module name</span>
<span class="n">String</span> <span class="n">module</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getModule</span><span class="o">();</span>
<span class="c1">// module name  -&gt; module class</span>
<span class="n">String</span> <span class="n">moduleClass</span> <span class="o">=</span> <span class="n">module</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">ModulesRepository</span><span class="o">.</span><span class="na">getModuleClass</span><span class="o">(</span><span class="n">module</span><span class="o">)</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
<span class="c1">// 判断是否在ban list里边</span>
<span class="o">......</span>
<span class="kt">boolean</span> <span class="n">shouldBan</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">shouldBan</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRemoteAddr</span><span class="o">());</span>
<span class="c1">// 主角出场</span>
<span class="n">out</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">processCommand</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">encoding</span><span class="o">,</span> <span class="n">context</span><span class="o">,</span> <span class="n">moduleClass</span><span class="o">);</span>
<span class="c1">// 扫尾工作,例如db的rollback</span>
<span class="k">this</span><span class="o">.</span><span class="na">handleFinally</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">forumContext</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
</code></pre></div></p>

<p>processCommand会调用Command的process方法：
<div class="highlight"><pre><code class="java"><span class="c1">// 获取一个module实例(继承了Command)</span>
<span class="n">Command</span> <span class="n">c</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">retrieveCommand</span><span class="o">(</span><span class="n">moduleClass</span><span class="o">);</span>
<span class="c1">// 进入process</span>
<span class="n">Template</span> <span class="n">template</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">context</span><span class="o">);</span>
<span class="c1">// 这里开始是process方法</span>
<span class="c1">//获取action</span>
<span class="n">String</span> <span class="n">action</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">request</span><span class="o">.</span><span class="na">getAction</span><span class="o">();</span>
<span class="c1">//如果不是ignore的，就调用这个action</span>
<span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">ignoreAction</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="n">action</span><span class="o">,</span> <span class="n">NO_ARGS_CLASS</span><span class="o">).</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">NO_ARGS_OBJECT</span><span class="o">);}</span>
<span class="c1">//如果是转发的，就把TemplateName清空</span>
<span class="k">if</span> <span class="o">(</span><span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">getRedirectTo</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">setTemplateName</span><span class="o">(</span><span class="n">TemplateKeys</span><span class="o">.</span><span class="na">EMPTY</span><span class="o">);}</span>
<span class="c1">//不是转发且attribute里边存在template，则设置为templateName</span>
<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">&quot;template&quot;</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">setTemplateName</span><span class="o">((</span><span class="n">String</span><span class="o">)</span><span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">&quot;template&quot;</span><span class="o">));}</span>
<span class="c1">//是否coustomContent？例如下载，验证码子类的不需要页面的操作</span>
<span class="k">if</span> <span class="o">(</span><span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">isCustomContent</span><span class="o">())</span> <span class="o">{</span><span class="k">return</span> <span class="kc">null</span><span class="o">;}</span>
<span class="c1">//返回一个template</span>
<span class="k">return</span> <span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">templateConfig</span><span class="o">().</span><span class="na">getTemplate</span><span class="o">(&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>            <span class="k">new</span> <span class="n">StringBuffer</span><span class="o">(</span><span class="n">SystemGlobals</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">ConfigKeys</span><span class="o">.</span><span class="na">TEMPLATE_DIR</span><span class="o">)).</span>
            <span class="n">append</span><span class="o">(</span><span class="sc">&#39;/&#39;</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">templateName</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// 从process出来，回到processCommand</span>
<span class="c1">// 设置content type</span>
<span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="n">contentType</span><span class="o">);</span>
<span class="c1">//生成页面并flush</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">isCustomContent</span><span class="o">())</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>            <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="n">OutputStreamWriter</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">(),</span> <span class="n">encoding</span><span class="o">));</span>
            <span class="n">template</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">getTemplateContext</span><span class="o">(),</span> <span class="n">out</span><span class="o">);</span>
            <span class="n">out</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre></div>
这是一般的流程，就像上面提到的customContent，就是要自己处理了，可以参考CaptchaAction.generate().</p>

<p>这样的话，如果我们要增加一些action进行<strong>二次开发</strong>的话，大体的流程就是，增加一个继承了Command的类，
例如叫ExampleAction,定义一个方法，例如叫test()，在urlPattern.properties中定义一个映射,
例如为example.test.1 = forum_id，再在modulesMapping.properties中定义module class的映射，
如example = ExampleAction，最后我们在templatesMapping.properties定义个模板的映射，
如：example.test = example_test.htm。现在假设我们的请求url是/example/test/1,再来看看test里边的一些方法：
<div class="highlight"><pre><code class="java"><span class="k">this</span><span class="o">.</span><span class="na">request</span><span class="o">.</span><span class="na">getIntParameter</span><span class="o">(</span><span class="s">&quot;forum_id&quot;</span><span class="o">))</span>  <span class="c1">//获取参数，得到1</span>
<span class="k">this</span><span class="o">.</span><span class="na">context</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;obj&quot;</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span> <span class="c1">//把结果写入context，这样可以在template中获取到</span>
<span class="k">this</span><span class="o">.</span><span class="na">setTemplateName</span><span class="o">(</span><span class="s">&quot;example.test&quot;</span><span class="o">);</span><span class="c1">//设置template的名字</span>
</code></pre></div>
这样的简单流程应该还比较好理解吧?</p>

<p>另外，还可以看出，jforum使用了自己的一套映射机制，这是通过urlPattern.properties来定义的
(参考上面JForumBaseServlet的init流程)，这是在JForumBaseServlet的loadConfigStuff方法的第一行实现的，
并加载到UrlPatternCollection中去，如下所示：
<div class="highlight"><pre><code class="java"><span class="n">Properties</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
<span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">SystemGlobals</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">ConfigKeys</span><span class="o">.</span><span class="na">CONFIG_DIR</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;/urlPattern.properties&quot;</span><span class="o">);</span>
<span class="n">p</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">fis</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">for</span> <span class="o">(</span><span class="n">Iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">();</span> <span class="n">iter</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
   <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="n">iter</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
   <span class="n">UrlPatternCollection</span><span class="o">.</span><span class="na">addPattern</span><span class="o">((</span><span class="n">String</span><span class="o">)</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></p>

<p>可以知道这里的key和value都是String来的
<div class="highlight"><pre><code class="java"><span class="n">UrlPatternCollection</span><span class="o">.</span><span class="na">patternsMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="k">new</span> <span class="n">UrlPattern</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">));</span>
</code></pre></div>
但在addPattern方法里边其实是生成一个UrlPattern作为value，如何<strong>构造一个UrlPattern</strong>可以看看代码，
举例来说把，对于example.hello.2=a,b,这样会生成一个UrlPattern,里边的内容是name为example.hello.2,value为a,b.
而size和vars是用a,b解析出来的，用来表示一共有多少个参数，参数名组成的数组。
所以UrlPattern存储的就是一个url格式的定义，而放在UrlPatternCollection里边的一系列的url映射格式是在请求的url解析的时候用到的。</p>

<p>现在再分析一下jforum怎么使用这个UrlPatternCollection的?按照我们不严格的思路，应该是service中处理url，
获取.page前面的一部分,如/example/hello/2/1，用/做一下split，获取module name，action name,
把最后的作为参数，用module,action,参数个数组成一个key(example.hello.2),通过UrlPatternCollection找到对应的UrlPattern，
通过里边的格式对应(vars里边的参数名和url的参数值)就可以把参数添加到request的parameters里边去。
实际的情况也差不多就这个样。在说到jforum中的service方法的时候，简单提到过request和response是经过包装的:
<div class="highlight"><pre><code class="java"><span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WebRequestContext</span><span class="o">(</span><span class="n">req</span><span class="o">);</span>
<span class="n">response</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WebResponseContext</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
</code></pre></div>
WebResponseContext只是简单的delegate给HttpServletResponse(这样做的好处是全部方法都限制在ResponseContext中)，
而WebRequestContext是继承了HttpServletRequestWrapper并实现了RequestContext接口。
所以WebRequestContext是一个HttpRequest，但是通过RequestContext接口实现了一些特定的方法就是了，
例如getModule/getAction，而这个解析url的过程是在构建WebRequestContext对象的过程中实现的。
可以看看WebResponseContext的构造方法，这里就不详细说了。注意的是，所有的parameters最后都保存到query(一个私有的map)里边去的。
还有就是上面说到的jforum的特定url映射机制，这是通过WebRequestContext的parseFriendlyURL方法实现的，
原理就和上面提到的那样，也不详说了。</p>

<p>到这里，基本上整个处理流程就差不多了。现在来说说jforum里边的文件修改监听器(JForumBaseServer的startApplication流程)，
如果你在使用jforum的过程中，修改了某些文件如*.sql，jforum就会重新加载修改后的配置。
我原来以为是用quartz框架来实现的，后来才知道是用jdk的TimerTask类来实现的。
请看ConfigLoader的listenForChanges方法：
<div class="highlight"><pre><code class="java"><span class="n">FileMonitor</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">addFileChangeListener</span><span class="o">(</span><span class="k">new</span> <span class="n">QueriesFileListener</span><span class="o">(),&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>            <span class="n">SystemGlobals</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">ConfigKeys</span><span class="o">.</span><span class="na">SQL_QUERIES_GENERIC</span><span class="o">),</span> <span class="n">fileChangesDelay</span><span class="o">);</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre></div></p>

<p>这里给各个部分分一下责任，FileMonitor是大管家，负责管理所有的文件监听器；FileChangeListener是一个监听器接口，
只有一个方法，就是fileChanged(String filename)，意思就是对某个filename的修改作出怎样的反应。
使用的方法也很简单，就是实现一个FileChangeListener，并和监控的文件名，检查间隔作为参数传入就可以生效了。
FileMonitor里边的实现原理就是，通过一个map(timerEntries)来保存(文件名/timertask),
每次加入一个监听器的时候，会根据文件名先移出原来的文件监听器(缺点是只能能对一个文件添加一个监听器)，
然后构建一个TimerTask并加入到timerEntries中去。关于TimerTask的具体用法，可以参考api。</p>

<p>作为一个论坛，应用层缓存这样的东西似乎必不可少，jforum也提供了缓存配置(上面也提到一些)。
jforum提供了数种<strong>缓存实现</strong>(JForumBaseServlet的init流程)，分别是DefaultCacheEngine(简单的内存实现),
JBossCacheEngine，EhCacheEngine。，请看ConfigLoader的startCacheEngine方法，
流程大概就是得到cacheEngine的实现配置(SystemGlobals.properties中配置cache.engine.implementation)，
然后产生CacheEngine的实例，调用它的init方法进行初始化，然后找到所有的可缓存类(实现了Cacheable接口，并在SystemGlobals.properties中配置cacheable.objects)，最后把cacheEngine注入进去获得cache的能力。
虽然jforum自己实现了许多这样的注入(除了cacheEngine，还有db，dao等等)，
虽然达到了一定的的目的，可是怎么说还是到处充满了Singleton的实现(参考spring2.5文档3.9. 粘合代码和可怕的singleton)，
为了寻求更好的组织方式(例如使用ioc来管理对象，使用成熟的orm来隔离数据库)和获得更多的用户群(选择更广泛使用的框架帮助)，
大概才会萌发jforum3的想法吧。</p>

<p>顺便提一下jforum的<strong>Dao实现方式</strong>(参考JForumBaseServlet的startApplication流程)，
参考ConfigLoader的loadDaoImplementation方法，原理就是通过配置dao.driver(在特定的数据库配置里边如mysql.properties):</p>

<pre><code>获取到DataAccessDriver的实现 -&gt; 初始化DataAccessDriver -&gt; 获取到所有的Dao实现。
</code></pre>

<p>可以这么理解，实现一个DataAccessDriver就获得一整套Dao的实现方式，对于dao里边的实现方法，给个范例：
<div class="highlight"><pre><code class="java"><span class="c1">//例行公事</span>
<span class="n">PreparedStatement</span> <span class="n">p</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="c1">//获得connect，并执行named sql</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">JForumExecutionContext</span><span class="o">.</span><span class="na">getConnection</span><span class="o">().</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">SystemGlobals</span><span class="o">.</span><span class="na">getSql</span><span class="o">(</span><span class="s">&quot;GroupModel.selectById&quot;</span><span class="o">));</span>
<span class="n">p</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">groupId</span><span class="o">);</span>
<span class="n">rs</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>
<span class="n">Group</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Group</span><span class="o">();</span>
<span class="c1">//循环resultset进行处理</span>
<span class="k">if</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span><span class="n">g</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getGroup</span><span class="o">(</span><span class="n">rs</span><span class="o">);}</span>
</code></pre></div></p>

<p>整个实现很直白，就是一个jdbc实现方式来的。对于如何获取connection，查看JForumExecutionContext的getConnection(),可以注意到这么一句：
<div class="highlight"><pre><code class="java"><span class="n">c</span> <span class="o">=</span> <span class="n">DBConnection</span><span class="o">.</span><span class="na">getImplementation</span><span class="o">().</span><span class="na">getConnection</span><span class="o">();</span>
</code></pre></div>
也是比较清晰的，另外可以知道的是，在每次请求的过程中，connection只会获取一次，
并在第一次获取到以后放到ThreadLocal里边去,这样在每个线程中保留一份数据(正确理解TheradLocal )，
在请求请求结束以后才释放connection(service流程中的handleFinally方法)。</p>

<p>JForumExecutionContext，如字面意，就是请求执行的上下文，例如上面提到的数据库连接，
还有ForumContext(放着和request，response相关的信息)，context(freemarker的上下文变量)，
redirectTo(转发地址)，contentType(响应内容格式)，isCustomContent(不使用默认渲染，上面有提到)，
enableRollback(db是否会滚)。</p>

<p>jforum是可以配置权限的，可控制的权限类型放在SecurityConstants里边，
对应的配置界面是根据permissions.xml生成的(参考GroupAction的permissions)。而每个用户的权限(PermissionControl)是通过SecurityRepository来管理的</p>

<pre><code>最用形成的权限系统是role(权限)－group(用户组,可以多级)－用户这样的结构图。
</code></pre>

<p>如何判断权限?
对于一个用户来说，为了获取用户的权限(PermissionControl)，流程是这样的(详细看SecurityRepository的load方法)：</p>

<pre><code>获取用户信息 -&gt; 获取用户的所有groupid并组成一个用逗号隔开的字符串groupids  -&gt; 根据groupids获取所有的name/role_value -&gt; 组装成RoleValueCollection －&gt; 生成RoleCollection -&gt; 最后生成PermissionControl
</code></pre>

<p>判断权限是使用SecurityRepository的canAccess(int userId, String roleName, String value)方法：</p>

<pre><code>根据userid获取PermissionControl-&gt; 如果value参数为空的话，就判断是否拥有该roleName(通过内部的RoleCollection对象的keys),就是是否含有该权限 -&gt; 如果value参数不为空的话，除了需要含有该权限，还要拥有相应的rolevalue(通过内部的RoleCollection对象的values)。参数中的value指数可以为论坛分类id，论坛id之类，随业务而定。
</code></pre>

<p>总体上jforum还算清晰，大部分的业务代码没有细看(那些Command类)，有兴趣可以对照着写，
大体分为三个包(admin是管理，jforum是公共页面，install是安装页面)。</p>

<p>既然说到验证，就顺便要说说jforum的<strong>sso验证机制</strong>
官方文档:</p>

<pre><code>http://www.jforum.net/doc/SSO
http://www.jforum.net/doc/ImplementSSO
http://www.jforum.net/doc/SSOcookies
http://www.jforum.net/doc/SSOremote
</code></pre>

<p>有上面这些文档基本可以自己实现一个，主要就是实现net.jforum.sso接口就是了。</p>

<p>在Jforum的service方法里边有段(service流程中的刷新session)：
<div class="highlight"><pre><code class="java"><span class="n">ControllerUtils</span> <span class="n">utils</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ControllerUtils</span><span class="o">()</span>
<span class="n">utils</span><span class="o">.</span><span class="na">refreshSession</span><span class="o">();</span><span class="c1">//重点</span>
</code></pre></div>
里边提到，在没有usersession的情况下，如果配置的验证类型是sso(authentication.type)：</p>

<pre><code>调用checkSSO(UserSession userSession)的方法 -&gt; 生成SSO实例(使用sso.implementation来配置) -&gt; 调用authenticateUser(RequestContext request)返回username -&gt; 假如取不到的username，就设为匿名 -&gt; 否则，如果不存在该用户(utils.userExists(username)则注册一个(utils.register(password, email)) -&gt; 假如已经存在,则让用户登录(configureUserSession(userSession, utils.getUser()))
</code></pre>

<p>当已经存在usersession的时候，并且验证方式是sso的时候，就是验证是否有效(sso.isSessionValid(userSession, request))。
所以，整个过程和官方文档提到的流程是一样的，如果要实现自己的sso，这是实现SSO接口，
使用authenticateUser来验证不存在usersession的情况，并返回username or null，
而使用isSessionValid来判断一个已经存在的usersession是否有效。
参考上面几个连接文档，实现和已有系统的sso集成，还是比较清晰明了的。</p>
]]></content>
  </entry>
  
</feed>
