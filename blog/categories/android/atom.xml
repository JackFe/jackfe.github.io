<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2016-04-17T15:41:51+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android-Universal-Image-Loader源码快扫]]></title>
    <link href="http://mccxj.github.com/blog/20150624_Android-Universal-Image-Loader-source-view.html"/>
    <updated>2015-06-24T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/Android-Universal-Image-Loader-source-view</id>
    <content type="html"><![CDATA[<h2>ImageLoaderConfiguration/ImageLoaderConfiguration.Builder学习</h2>

<p>构造复杂对象的方式: Builder模式,用来创建ImageLoaderConfiguration对象,适用于链式写法。</p>

<p>常见结构如下：<strong>关键点: 私有构造(拷贝而非应用，避免build复写)、内部类(影响局部化,内聚好)、返回this(支持链式)</strong>
```java
class A {
  private A(Builder builder) {</p>

<pre><code>// create A with builder's copy
</code></pre>

<p>  }</p>

<p>  public static class Builder{</p>

<pre><code> Builder buildStep1(){
    //...
    return this;
 }

 Builder buildStep2(){
    //...
    return this;
 }   

 A build() {
    return new A(this);
 }  
</code></pre>

<p>  }
}
```</p>

<h2>ImageLoaderConfiguration支持的特性</h2>

<p><code>
-- 源码没什么养分，关注特性是如何表现在内部结构上。
-- 类层次的结构，能体会就体会，不体会就拉到。层次是渐进实现的，不能体会也没什么。
-- 如果有机会的话，可以在实践项目中调试进去学学。
</code></p>

<p>如果想学习相关特性是怎么实现的，可以根据配置的去反推实现代码(搜索或调用关系):
```
基本特性（可配置）:
  基本控制:</p>

<pre><code>线程池大小 -- 不能太多
线程优先级 -- 略低
请求任务排队  -- 默认FIFO
是否开启调试日志 -- DEBUG log
</code></pre>

<p>  多级缓存特性:</p>

<pre><code>内存缓存大小
硬盘缓存大小，文件数量限制，文件名生成规则
-- 关联硬盘图片处理器BitmapProcessor
</code></pre>

<p>  图片专用:</p>

<pre><code>缓存图最大宽高 --- 用于约束图片大小
显示图的约束
-- 关联下载器ImageDownloader(还通过networkDeniedDownloader/slowNetworkDownloader区分不同情况，这不就是Null Object模式么?)
-- 关联解码器ImageDecoder
</code></pre>

<p>```</p>

<h2>关于ImageLoader如何解决错乱问题</h2>

<p>ImageLoader就是一个singleton实现，配合init+ImageLoaderConfiguration进行初始化，没什么说的。很常见的设计实现。</p>

<p>大多是helper method 关注displayImage/loadImage最终实现即可。这也是常见做法，便于使用。</p>

<p>问题: url -- 关联的view，问题在于url请求是异步的，而view可能被重复利用。<br/>
这里用的ImageAware，看他们的实现类，有个ViewAware，就是一个view的包装，我想说的是WeakReference在android中很常用呀。 -- 这句是废话</p>

<p><code>
使用ImageAware占位
  图片宽高
  实际的View --可重用
  id -- 尼玛，这是解决问题的关键
</code></p>

<p>见DisplayBitmapTask有个isViewWasReused倒出重点，从它的实现就可以判断完整的算法拉。</p>

<p>内部结构 cacheKeysForImageAwares map&lt;ImageAware.id, memorycachekey(由URI + 宽高生成)></p>

<p>不过ViewAware的id是用view的hashcode来指定的， NonViewAware的id是用url来指定的。<br/>
so， listview的时候，使用loadImage是可以避免错乱的，而用displayImage就呵呵拉。<br/>
判断方式如下：根据id可以找到目前的url和当前的url比较即可。知道是不是被复用了。</p>

<p>相对于原理上的image#setTag(url)然后比较的方式，更加透明，侵入性少。</p>

<h2>再看看ImageLoaderEngine在任务管理、线程方面的处理</h2>

<p>原以为这货应该比较好处理，图样图森破呀，毕竟它支持多种状态(暂停，恢复，关闭等)</p>

<p>先说一下几个AtomicBoolean的变量，主要就是判断状态的boolean拉，当然这货是线程安全的，其实用boolean也行，毕竟也是原子的(注意可见性问题即可)
```</p>

<pre><code>private final AtomicBoolean paused = new AtomicBoolean(false);
private final AtomicBoolean networkDenied = new AtomicBoolean(false);
private final AtomicBoolean slowNetwork = new AtomicBoolean(false);`
</code></pre>

<p>```</p>

<p>另外，还有3个线程执行器，简单看看用途。至于为什么要这么多个，哥认为是这样的：</p>

<ul>
<li>在loader中走进displayImage之后，它重要检查一下内存中有木有(耗时小，无需线程)。</li>
<li>如果没有才会扔给engine，engine首先检查一下硬盘上有木有(有io，所以走taskDistributor)。</li>
<li>如果硬盘上有，走taskExecutorForCachedImages(同理有io)</li>
<li>还是没有，走其他(maybe网络io)</li>
<li>在请求较多，兼顾命中、不命中的情况，它选择了采用多级的Executor</li>
</ul>


<p>```</p>

<pre><code>private Executor taskExecutor; -- 木有在disk的情况，一般走网络
private Executor taskExecutorForCachedImages; -- 在disk的情况
private Executor taskDistributor;  -- 根据情况分发给上面2个
</code></pre>

<p>```</p>

<p>还有2个map，第一个就是用来保存id和图片url的对应关系(简单是这么理解)<br/>
另外是用来控制不同view但有相同uri的并发请求。
```</p>

<pre><code>private final Map&lt;Integer, String&gt; cacheKeysForImageAwares = Collections
        .synchronizedMap(new HashMap&lt;Integer, String&gt;());
private final Map&lt;String, ReentrantLock&gt; uriLocks = new WeakHashMap&lt;String, ReentrantLock&gt;();
</code></pre>

<p>```</p>

<p>不熟悉ReentrantLock的童鞋可参考 https://www.ibm.com/developerworks/cn/java/j-jtp10264/</p>

<p>LoadAndDisplayImageTask通过控制相同的uri持有同一个锁，这样执行的时候，后面的就会等待。<br/>
具体可以参考LoadAndDisplayImageTask的实现，不过用ReentrantLock需要特别注意写法，避免死锁。<br/>
不过我认为getLockForUri并没有同步，还是有存在相同url获取到不同lock的可能，不过这不影响功能，而且受限于并发大小也很难出现。</p>

<h2>关于url的中文</h2>

<p>网上有看到一些人说中文图片名会出错，可能是很久之前的版本吧。我这里要说的是，我认为这是个简单的问题，即使改源码也很容易处理。<br/>
不过即使源码有相关处理，通常也不会关注的，不过今天刚好有人问我一个中文路径的问题，所以我就关注了一下它怎么实现的。</p>

<p>首先看BaseImageDownloader是如何请求中文图片的。由于http只是支持ascii的url编码，所以必须要编码的，通常用utf-8,虽然这个没规定。貌似我们的基线没有考虑这个问题，应该是没有掉过坑。
```</p>

<pre><code>protected HttpURLConnection createConnection(String url, Object extra) throws IOException {
    String encodedUrl = Uri.encode(url, ALLOWED_URI_CHARS);
    HttpURLConnection conn = (HttpURLConnection) new URL(encodedUrl).openConnection();
    conn.setConnectTimeout(connectTimeout);
    conn.setReadTimeout(readTimeout);
    return conn;
}
</code></pre>

<p>```</p>

<p>另外，还有一个容易出现中文问题的就是保存到硬盘的情况(android貌似不是什么大问题，如果是做server开发的话，就得特别注意)<br/>
带的实现有HashCodeFileNameGenerator(默认)和Md5FileNameGenerator，这2种处理都不会产生中文问题。<br/>
不过我建议还是用Md5FileNameGenerator，hashcode做唯一性并不是很靠谱，如果是大量的固定文件名长度的图片，还是很容易冲突的。</p>

<h2>小结</h2>

<p>源码何其多，带着问题学习效果更好。挑几个疑惑看看别人怎么处理就是收获。  <br/>
从类的层次着手是很困难的，特别是大型源码。了解上层架构，学示例，然后调调源码或许更好。
大多数情况，相对于细节，应该更关注关键数据的结构、如何组织数据的结构来解决问题。<br/>
如果自己设计，应该考虑的重要问题有: 如何使用? 用怎样的结构表示数据和状态? <br/>
XX设计模式不要硬套，从过程式演变出来更加自然(经验性的除外)。推荐重构与模式。<br/>
大而全的源码解读没有什么用，带问题分析的更有价值。<br/>
学好基础，模仿起来也不容易掉坑。</p>

<p>-- 以上纯属肉眼分辨，并无调试过，不做正确性验证，仅供参考。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android+maven问题记录]]></title>
    <link href="http://mccxj.github.com/blog/20140219_android-maven-problems.html"/>
    <updated>2014-02-19T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/android-maven-problems</id>
    <content type="html"><![CDATA[<h2>参考材料</h2>

<ul>
<li>https://code.google.com/p/maven-android-plugin/wiki/GettingStarted</li>
<li>http://books.sonatype.com/mvnref-book/reference/android-dev.html</li>
<li>http://www.ikoding.com/build-android-project-with-maven/</li>
<li>https://github.com/mosabua/maven-android-sdk-deployer</li>
<li>http://rgladwell.github.io/m2e-android/</li>
<li>http://wiki.eclipse.org/M2E_plugin_execution_not_covered</li>
</ul>


<h2>前提条件</h2>

<ul>
<li>JDK 1.6+</li>
<li>Android SDK r21.1+</li>
<li>Maven 3.1.1+</li>
<li>Set environment variable ANDROID_HOME to the path of your installed Android SDK and add $ANDROID_HOME/tools as well as $ANDROID_HOME/platform-tools to your $PATH. (or on Windows %ANDROID_HOME%\tools and %ANDROID_HOME%\platform-tools)</li>
</ul>


<p>特别注意maven的版本号</p>

<h2>maven配置</h2>

<p>请设置环境变量M2_HOME，并把settings.xml放到M2_HOME/conf中去。</p>

<h2>eclipse配置</h2>

<p>对于eclipse来说，除了要maven插件，还需要<a href="http://rgladwell.github.io/m2e-android/">m2e-android</a>插件。</p>

<h2>dependency中support-v4的版本号只有很旧r7</h2>

<p>其实除了support-v4,像android也有类似的问题。有一种解决方案是采用<a href="https://github.com/mosabua/maven-android-sdk-deployer">maven-android-sdk-deployer</a>。
我测试过之后，发现这个解决方案虽然可行，但实际上比较麻烦。我直接在公司内的代理仓库上安装了新版本的。</p>

<h2>Plugin execution not covered by lifecycle configuration</h2>

<p>pom.xml很可能出现下面的错误提示:</p>

<p><code>bash
Plugin execution not covered by lifecycle configuration:
 com.jayway.maven.plugins.android.generation2:android-maven-plugin:3.8.2:consume-aar
 (execution: default-consume-aar, phase: compile)
</code></p>

<p>虽然不影响编译，但是很怪，可以通过下面的配置进行排除:</p>

<p>```xml
<pluginManagement></p>

<pre><code>&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt;
        &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;configuration&gt;
            &lt;lifecycleMappingMetadata&gt;
                &lt;pluginExecutions&gt;
                    &lt;pluginExecution&gt;
                        &lt;pluginExecutionFilter&gt;
                            &lt;groupId&gt;com.jayway.maven.plugins.android.generation2&lt;/groupId&gt;
                            &lt;artifactId&gt;android-maven-plugin&lt;/artifactId&gt;
                            &lt;versionRange&gt;3.8.2&lt;/versionRange&gt;
                            &lt;goals&gt;
                                &lt;goal&gt;manifest-update&lt;/goal&gt;
                                &lt;goal&gt;generate-sources&lt;/goal&gt;
                                &lt;goal&gt;proguard&lt;/goal&gt;
                                &lt;goal&gt;consume-aar&lt;/goal&gt;
                            &lt;/goals&gt;
                        &lt;/pluginExecutionFilter&gt;
                        &lt;action&gt;
                            &lt;ignore /&gt;
                        &lt;/action&gt;
                    &lt;/pluginExecution&gt;
                &lt;/pluginExecutions&gt;
            &lt;/lifecycleMappingMetadata&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>

<p></pluginManagement>
```</p>

<p>可以参考<a href="http://wiki.eclipse.org/M2E_plugin_execution_not_covered">M2E_plugin_execution_not_covered</a></p>

<h2>OutOfMemory或创建不了虚拟机</h2>

<p>有时候会出现内存溢出或创建不了虚拟机的错误。考虑设置内存大小</p>

<p>```xml
<plugin></p>

<pre><code>&lt;groupId&gt;com.jayway.maven.plugins.android.generation2&lt;/groupId&gt;
&lt;artifactId&gt;android-maven-plugin&lt;/artifactId&gt;
&lt;configuration&gt;
    &lt;dex&gt;
        &lt;jvmArguments&gt;
            &lt;jvmArgument&gt;-Xms256m&lt;/jvmArgument&gt;
            &lt;jvmArgument&gt;-Xmx512m&lt;/jvmArgument&gt;
        &lt;/jvmArguments&gt;
    &lt;/dex&gt;
&lt;/configuration&gt;
</code></pre>

<p></plugin>
```</p>

<h2>出现maven打包太慢的情况</h2>

<p>经过测量，在dex成classes.dex的阶段比较慢，dx工具有提供一些参数进行优化.</p>

<ul>
<li>incremental 增量打包，开发阶段可以开启，可以比较明显的缩短打包时间</li>
<li>optimize 是否优化classes.dex，开发阶段可以关闭</li>
</ul>


<p><code>xml
&lt;dex&gt;
  &lt;incremental&gt;true&lt;/incremental&gt;
  &lt;optimize&gt;false&lt;/optimize&gt;
&lt;/dex&gt;
</code></p>

<h2>libpng error: Not a PNG file</h2>

<p>如果直接把jpg格式换个名字，变成png，编译会报下面的错误，导致后面编译的.9图片也出问题(混淆问题的原因)</p>

<p><code>bash
[INFO] libpng error: Not a PNG file
[INFO] ERROR: Failure processing PNG image E:\projects\G3ESOP\ESOP-Hubei2\res\drawable-xhdpi\more_about_pic1.png
</code></p>

<h2>'build.plugins.plugin.version' is missing</h2>

<p><code>bash
[WARN] 'build.plugins.plugin.version' is missing fororg.apache.maven.plugins:maven.compiler.plugin
It is highly recommended to fix these problems because they threaten the stability of your build.
For this reason, future Maven versions might no longer support building such malformed projects.
</code></p>

<p>很简单，给maven.compiler.plugin这个插件添加version属性。
其实所有引用的插件都应该指定版本，不然都会有类似的提示。</p>

<h2>关于编码</h2>

<p>对于源码的编码格式和编译版本，应该进行指定:</p>

<p>```xml
<plugin></p>

<pre><code>&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
&lt;version&gt;3.1&lt;/version&gt;
&lt;configuration&gt;
    &lt;source&gt;1.6&lt;/source&gt;
    &lt;target&gt;1.6&lt;/target&gt;
    &lt;encoding&gt;UTF8&lt;/encoding&gt;
&lt;/configuration&gt;
</code></pre>

<p></plugin>
```</p>

<p>对于资源处理的话，可能出现下面的提示:</p>

<p><code>bash
[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!
</code></p>

<p>这个应该设置成UTF-8，如下所示:</p>

<p>```xml</p>

<pre><code>        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
            &lt;configuration&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
</code></pre>

<p>```</p>

<h2>maven-jarsigner-plugin对带特殊字符的口令的处理</h2>

<p>这个弄了好久，最后发现得把密码用引用引起来。切记切记。</p>

<p>后来，发现在linux这样又不能支持。所以只能用profile解决。</p>

<h2>部分代码在jdk7中编译后dex出错</h2>

<p>参考<a href="/blog/20140225_android-jdk7-bug.html">jdk7编译的bug记录</a>,暂时只用jdk6编译</p>

<h2>jdk6不支持android-19的proguard</h2>

<p>原因是android-19的API实现了一些jdk7的特性，在proguard会找不到这些api。
由于和上一个问题有些冲突，暂时不考虑proguard。后续考虑考虑上jdk7。</p>

<h2>如何添加.so支持</h2>

<p>例如下面的百度地图SDK，需要加入一个so文件，在百度SDK里边是这样调用的：</p>

<p><code>java
System.loadLibrary("BaiduMapSDK_v2_3_1");
</code></p>

<p>如果要用maven集成的话，可以用下面的配置(已经部署到代理仓库):</p>

<p>```xml
<dependency></p>

<pre><code>&lt;groupId&gt;com.baidu&lt;/groupId&gt;
&lt;artifactId&gt;libBaiduMapSDK_v2_3_1&lt;/artifactId&gt;
&lt;version&gt;2.3.1&lt;/version&gt;
&lt;classifier&gt;armeabi&lt;/classifier&gt;
&lt;scope&gt;runtime&lt;/scope&gt;
&lt;type&gt;so&lt;/type&gt;
</code></pre>

<p></dependency>
```</p>

<h2>如何转换成eclipse项目</h2>

<p>项目目录中只有pom.xml，如果要导入eclipse的话，可以考虑使用下面的命令生成.project和.classpath文件</p>

<p><code>bash
mvn eclipse:eclipse
</code></p>

<p>生成之后可能会有M2_REPO变量找不到的问题，可以在eclipse中通过window>Preferences>Maven>Installations>Add进行添加maven安装位置。</p>

<p>否则的话，可以按以下方法添加M2_REPO: Window > Preferences > Java > Build Path > Classpath Variables
新增一个M2_REPO变量指向你maven本地仓库。</p>

<h2>常用命令</h2>

<p>mvn clean package<br/>
打包，但不部署。</p>

<p>mvn clean install<br/>
打包，部署并运行。</p>

<p>mvn clean package android:redeploy android:run<br/>
这个命令通常用于手机上已经安装了要部署的应用，但签名不同，所以我们打包的同时使用redeploy命令将现有应用删除并重新部署，最后使用run命令运行应用。</p>

<p>mvn android:redeploy android:run<br/>
不打包，将已生成的包重新部署并运行。</p>

<p>mvn android:deploy android:run<br/>
部署并运行已生成的包，与redeploy不同的是，deploy不会删除已有部署和应用数据</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对UC文章《实时监控Android设备网络包》的补充]]></title>
    <link href="http://mccxj.github.com/blog/20131227_android-tcpdump-netcat-addon.html"/>
    <updated>2013-12-27T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/android-tcpdump-netcat-addon</id>
    <content type="html"><![CDATA[<p>补充的内容，主要是一些细节的问题，备忘.</p>

<h2>编译netcat</h2>

<p>android上自己好像带了一个，不过也可以自己编译一个。 我这里使用cygwin来编译的，首先去下载源码。</p>

<p>```bash</p>

<h1>cygwin</h1>

<p>cd /cygdrive/d/
mkdir -p netcat/toolchain</p>

<p>export NDK=/cygdrive/d/android-ndk-r8e
/cygdrive/d/android-ndk-r8e/build/tools/make-standalone-toolchain.sh --platform=android-8 --install-dir=netcat/toolchain
export PATH='pwd'/netcat/toolchain/bin:$PATH
export CC=arm-linux-androideabi-gcc
export RANLIB=arm-linux-androideabi-ranlib
export AR=arm-linux-and roideabi-ar
export LD=arm-linux-androideabi-ld</p>

<h1>开始编译源码</h1>

<p>cd netcat-0.7.1/
./configure —host=arm-linux
make</p>

<h1>用file进行检测一下</h1>

<p>file src/netcat
src/netcat: ELF 32-bit LSB executable, ARM, version1 (SYSV), ...</p>

<h1>发到android上去</h1>

<p>adb push src/netcat /data/local/netcat
adb shell chmod 777 /data/local/netcat
```</p>

<h2>tcpdump的使用</h2>

<p>如果只是监听所有的包，可以用下面的：
<code>bash
adb shell "tcpdump -n -s 0 -w - | nc -I -p 11233"
</code></p>

<p>如果先监听端口的话，又想转发的话，写法有点特别。
<code>bash
adb shell "tcpdump -X -n -s 0 -w - port 5000 | nc -l -p 11233"
</code></p>

<p>另外，如果像我这样，有cygwin的话，就已经有nc命令了，可以像下面一样进行转发。
<code>bash
adb forward tcp:11333 tcp:11233 &amp;&amp; nc -v 127.0.0.1 | /cygdriver/d/Wireshark/Wireshark.exe -k -S -i -
</code></p>
]]></content>
  </entry>
  
</feed>
