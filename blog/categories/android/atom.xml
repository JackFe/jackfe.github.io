<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | 小毛的胡思乱想]]></title>
  <link href="http://mccxj.github.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://mccxj.github.com/"/>
  <updated>2016-06-23T13:28:42+08:00</updated>
  <id>http://mccxj.github.com/</id>
  <author>
    <name><![CDATA[蔡晓建]]></name>
    <email><![CDATA[mc02cxj@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于android ndk的jni总结]]></title>
    <link href="http://mccxj.github.com/blog/20151028_android-ndk-jni.html"/>
    <updated>2015-10-28T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/android-ndk-jni</id>
    <content type="html"><![CDATA[<h2>开发工具支持</h2>

<p>主要要点如下，更详细的应该参考官方文档:</p>

<ol>
<li>需要下载android ndk，并设置ANDROID_NDK_HOME并设置PATH, 在eclipse中顺便也设置一下。</li>
<li>eclipse支持android ndk开发，只需要在项目中右键添加Android Tools > Add Native Support即可。</li>
</ol>


<h2>配置文件</h2>

<p>主要配置文件有2个: Android.mk,Application.mk,详细配置还是应该阅读官方文档。下面说一下常用配置。</p>

<h4>Application.mk</h4>

<p>详细配置参考https://developer.android.com/intl/zh-cn/ndk/guides/application_mk.html</p>

<ul>
<li>APP_STL := stlport_static 设置是否依赖的C++标准库特性，非常重要，详细参数参考https://developer.android.com/intl/zh-cn/ndk/guides/cpp-support.html#runtimes</li>
<li>APP_ABI := armeabi armeabi-v7a 设置需要生成so的平台，可以指定或者用all</li>
<li>APP_OPTIM := release 生成debug还是relase版本，默认就是release</li>
</ul>


<h4>Android.mk</h4>

<p>详细配置参考https://developer.android.com/intl/zh-cn/ndk/guides/android_mk.html<br/>
这个配置是可以一次性生成多个so文档的，只需要区分不同的LOCAL_MODULE、LOCAL_SRC_FILES即可。</p>

<p><strong>发现ndk好像默认不支持c/c++混编，所以最好统一成cpp后缀。又或者是我不清楚实际是可以的</strong></p>

<ul>
<li>LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -lz -llog -landroid 依赖的库，这个例子表示依赖zlib、android log模块及android运行库</li>
<li>LOCAL_MODULE    := protect 生成的模块名</li>
<li>LOCAL_SRC_FILES := NativeApplication.cpp NativeHelper.cpp arcfour.cpp MultiDex.cpp 就是把so需要的相关源文件列出来</li>
</ul>


<h2>jni编程</h2>

<p>剩下的内容和Android都没特别关系了，都是java jni的知识。
对于android中jni的各种限制，可以参考官方文档： http://developer.android.com/intl/zh-cn/training/articles/perf-jni.html</p>

<h4>生成native方法的头文件</h4>

<p>和普通java的没区别，用javah就可以了，就是需要在classpath中添加android的jar即可。举例:</p>

<p><code>bash
cd native
javah -cp ./bin/classes;D:\05programs\Android\android-windows\platforms\android-19\android.jar -d ./jni com.huawei.g3.proxy.NativeApplication
</code></p>

<p>默认生成的方法名是有特殊命名规则的(具体规则请自行查阅资料)，如果需要不同名字，可以在JNI_OnLoad中进行动态注册，参考如下：</p>

<p>```c++
void load(JNIEnv * env, jclass clz, jobject obj);
void run(JNIEnv * env, jclass clz, jobject obj);
static JNINativeMethod methods[] = { { "load", "(Landroid/app/Application;)V", (void*) load }, { "run", "(Landroid/app/Application;)V",</p>

<pre><code>    (void*) run } };
</code></pre>

<p>jint JNI_OnLoad(JavaVM<em> vm, void</em> reserved) {</p>

<pre><code>JNIEnv* env;
if (vm-&gt;GetEnv(reinterpret_cast&lt;void**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) {
    return JNI_ERR;
}

// Register methods with env-&gt;RegisterNatives.
int len = sizeof(methods) / sizeof(methods[0]);
jclass native = env-&gt;FindClass("com/huawei/g3/proxy/NativeApplication");
if (env-&gt;RegisterNatives(native, methods, len) &lt; 0) {
    return JNI_ERR;
}
return JNI_VERSION_1_6;
</code></pre>

<p>}
```</p>

<h4>调用java对象、方法、属性</h4>

<p>当需要和java进行交互的时候，需要通过特定的api进行调用(类似java的反射，比较麻烦)，这种方式是绕过java安全检查机制的。</p>

<p>首先，需要了解jni中的类型表示法(基本就是java字节码那套表示法)，<strong>特别注意的是内部类的写法</strong></p>

<table>
<thead>
<tr>
<th></th>
<th> Type Signature            </th>
<th> Java Type             </th>
<th> 备注                              </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Z                         </td>
<td> boolean               </td>
<td>                                   |</td>
</tr>
<tr>
<td></td>
<td> B                         </td>
<td> byte                  </td>
<td>                                   |</td>
</tr>
<tr>
<td></td>
<td> C                         </td>
<td> char                  </td>
<td>                                   |</td>
</tr>
<tr>
<td></td>
<td> S                         </td>
<td> short                 </td>
<td>                                   |</td>
</tr>
<tr>
<td></td>
<td> I                         </td>
<td> int                   </td>
<td>                                   |</td>
</tr>
<tr>
<td></td>
<td> J                         </td>
<td> long                  </td>
<td>                                   |</td>
</tr>
<tr>
<td></td>
<td> F                         </td>
<td> float                 </td>
<td>                                   |</td>
</tr>
<tr>
<td></td>
<td> D                         </td>
<td> double                </td>
<td>                                   |</td>
</tr>
<tr>
<td></td>
<td> L fully-qualified-class ; </td>
<td> fully-qualified-class </td>
<td> Ljava/lang/String; 或内部类Lcom/test/A$B; |</td>
</tr>
<tr>
<td></td>
<td> [ type                    </td>
<td> type[]                </td>
<td> [I 或 [Ljava/lang/String;                                  |</td>
</tr>
<tr>
<td></td>
<td> ( arg-types ) ret-type    </td>
<td> method type           </td>
<td> ()V 或 (Ljava/lang/String;I)Z                                  |</td>
</tr>
<tr>
<td></td>
<td> V                         </td>
<td> void                  </td>
<td>                                   |</td>
</tr>
</tbody>
</table>


<p>看懂上面一套表示法，下面的代码也比较容易理解了:</p>

<p>```c++
jclass contextClass = env->FindClass("android/content/Context");
jfieldID fieldID = env->GetStaticFieldID(contextClass, "MODE_PRIVATE", "I");
jint mpFv = (jint) env->GetStaticIntField(contextClass, fieldID);</p>

<p>jstring _payload_dex = env->NewStringUTF("payload_dex");</p>

<p>jclass appClass = env->FindClass("android/app/Application");
jmethodID methodID = env->GetMethodID(appClass, "getDir", "(Ljava/lang/String;I)Ljava/io/File;");
jobject dex = env->CallObjectMethod(obj, dirMd, _payload_dex, mpFv); //obj是Application对象，传进来的
```</p>

<p><strong>需要注意的时候，FindClass参数中类名是不以L开头，不以;结束的</strong></p>

<p>上面的代码，其实就完成了下面一句java代码:</p>

<p><code>java
File dex = obj.getDir("payload_dex", Context.MODE_PRIVATE);
</code></p>

<p>基本套路都是一样的： 找到类、找到方法或属性、调用方法或调用属性，对应的是jclass、jmethodID、jfieldID几种类型。<br/>
详细的方法应该参考jni的官方文档，也很好理解。</p>

<p><code>c++
* CallStatic&lt;type&gt;Method
* Call&lt;type&gt;Method
* SetStatic&lt;type&gt;Field
* Set&lt;type&gt;Field
* GetStatic&lt;type&gt;Field
* Get&lt;type&gt;Field
</code></p>

<p>这里主要讲一下注意点:</p>

<ul>
<li>不带后缀、带V、带A的方法名有什么区别</li>
</ul>


<p>以CallObjectMethod为例，会存在三个方法:  CallObjectMethod, CallObjectMethodV, CallObjectMethodA
这个方法都是返回Object对象(jobject)的，效果是没什么区别的，只在于参数传递机制上存在区别。</p>

<ul>
<li>类型能不完全匹配么?</li>
</ul>


<p>像java反射那样，获取方法是可以不指定参数类型的。但是jni的类型是必须完全匹配的，
例如找方法void get(HashMap map)的时候，需要使用"(Ljava/util/HashMap;)V", 而不能使用"(Ljava/util/Map;)V"。</p>

<p>这种问题在处理api兼容性的时候就特别突出。例如下面的代码:</p>

<p>```c++</p>

<pre><code>if (version &lt; 19) {
    //using hashmap
    ft1 = "Ljava/util/HashMap;";
    ft2 = "java/util/HashMap";
} else {
    //using arraymap
    ft1 = "Landroid/util/ArrayMap;";
    ft2 = "android/util/ArrayMap";
}

jobject mPackages = _getField(env, currentActivityThread, "mPackages", ft1);
...    
jmethodID methodID = _getMethod(env, ft2, "get", "(Ljava/lang/Object;)Ljava/lang/Object;");
jobject wr = env-&gt;CallObjectMethod(mPackages, methodID, (jobject) pk);
</code></pre>

<p>```</p>

<p>在java中就可以不用那么烦躁，获取mPackages对象，强制转换成两个类的共同接口Map即可，省事很多。</p>

<ul>
<li>关于引用、字符串、异常处理</li>
</ul>


<p>在jni中主要有LocalRef、GlobalRef两种。正常产生的jobject对象，是属于LocalRef的，它的生命周期在当前线程的当前方法有效，类似于c/c++在栈分配的对象。 <br/>
<strong>官方tips也提到了，即使这个对象本身在本地方法返回之后仍然存在，这个引用也是无效的。而实际上只预留了16个LocalRef空间</strong></p>

<p>所以在使用上需要特别注意:</p>

<ol>
<li>不要过度分配LocalRef，及时通过DeleteLocalRef方法进行删除。或者通过EnsureLocalCapacity/PushLocalFrame预留更多，不过貌似很少需要。</li>
<li>如果需要在多次调用中保留，应该采用GlobalRef。通过NewGlobalRef/DeleteGlobalRef手动维护引用。</li>
<li>和反射一样，查找类、获取方法、获取属性都是有消耗的，在频繁调用的jni方法中，应该通过GlobalRef预先保留相关对象。</li>
<li>对于stirng类，如果和原生c字符串进行转换操作的时候，需要注意释放内存。</li>
<li>虽然C++本身也有异常处理，但是切记空指针异常不同于java，需要注意可能为NULL的代码。</li>
<li>不像java传参是传值(对象是隐含指针传递)，在c++中要注意区分传值、传指针、传引用。</li>
</ol>


<h4>通过GlobalRef优化jni的例子</h4>

<p>注意: jint等基本类型、jmethodID、jfieldID都不是jobject，不需要管理引用。
```c++
static jobject decryptCipher;</p>

<p>jint JNI_OnLoad(JavaVM<em> vm, void</em> reserved) {</p>

<pre><code>    ...
jobject localDecryptCipher = env-&gt;CallStaticObjectMethod(cipher, mid,
        desbuf);
decryptCipher = (jobject) env-&gt;NewGlobalRef(localDecryptCipher);
env-&gt;DeleteLocalRef(localDecryptCipher);
</code></pre>

<p>}</p>

<p>void JNI_OnUnload(JavaVM <em>vm, void </em>reserved) {</p>

<pre><code>    ...
if (decryptCipher != NULL) {
    env-&gt;DeleteGlobalRef(decryptCipher);
}
if (encryptCipher != NULL) {
    env-&gt;DeleteGlobalRef(encryptCipher);
}
</code></pre>

<p>}
```</p>

<h4>操作java字符串、c字符串的例子</h4>

<p>```c++</p>

<pre><code>const char *c_msg2 = env-&gt;GetStringUTFChars(dataDir, NULL);  // dateDir是jstring对象
string libPath(c_msg2);
env-&gt;ReleaseStringUTFChars(dataDir, c_msg2); // 和GetStringChars不同，GetStringUTFChars方法会分配内存并进行拷贝到c字符串，所以需要手动释放
libPath.append("/lib");
LOGI("lib path is %s", libPath.c_str());
jstring libDir = env-&gt;NewStringUTF(libPath.c_str()); // 重新转换成jstring
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android-Universal-Image-Loader源码快扫]]></title>
    <link href="http://mccxj.github.com/blog/20150624_Android-Universal-Image-Loader-source-view.html"/>
    <updated>2015-06-24T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/Android-Universal-Image-Loader-source-view</id>
    <content type="html"><![CDATA[<h2>ImageLoaderConfiguration/ImageLoaderConfiguration.Builder学习</h2>

<p>构造复杂对象的方式: Builder模式,用来创建ImageLoaderConfiguration对象,适用于链式写法。</p>

<p>常见结构如下：<strong>关键点: 私有构造(拷贝而非应用，避免build复写)、内部类(影响局部化,内聚好)、返回this(支持链式)</strong>
```java
class A {
  private A(Builder builder) {</p>

<pre><code>// create A with builder's copy
</code></pre>

<p>  }</p>

<p>  public static class Builder{</p>

<pre><code> Builder buildStep1(){
    //...
    return this;
 }

 Builder buildStep2(){
    //...
    return this;
 }   

 A build() {
    return new A(this);
 }  
</code></pre>

<p>  }
}
```</p>

<h2>ImageLoaderConfiguration支持的特性</h2>

<p><code>
-- 源码没什么养分，关注特性是如何表现在内部结构上。
-- 类层次的结构，能体会就体会，不体会就拉到。层次是渐进实现的，不能体会也没什么。
-- 如果有机会的话，可以在实践项目中调试进去学学。
</code></p>

<p>如果想学习相关特性是怎么实现的，可以根据配置的去反推实现代码(搜索或调用关系):
```
基本特性（可配置）:
  基本控制:</p>

<pre><code>线程池大小 -- 不能太多
线程优先级 -- 略低
请求任务排队  -- 默认FIFO
是否开启调试日志 -- DEBUG log
</code></pre>

<p>  多级缓存特性:</p>

<pre><code>内存缓存大小
硬盘缓存大小，文件数量限制，文件名生成规则
-- 关联硬盘图片处理器BitmapProcessor
</code></pre>

<p>  图片专用:</p>

<pre><code>缓存图最大宽高 --- 用于约束图片大小
显示图的约束
-- 关联下载器ImageDownloader(还通过networkDeniedDownloader/slowNetworkDownloader区分不同情况，这不就是Null Object模式么?)
-- 关联解码器ImageDecoder
</code></pre>

<p>```</p>

<h2>关于ImageLoader如何解决错乱问题</h2>

<p>ImageLoader就是一个singleton实现，配合init+ImageLoaderConfiguration进行初始化，没什么说的。很常见的设计实现。</p>

<p>大多是helper method 关注displayImage/loadImage最终实现即可。这也是常见做法，便于使用。</p>

<p>问题: url -- 关联的view，问题在于url请求是异步的，而view可能被重复利用。<br/>
这里用的ImageAware，看他们的实现类，有个ViewAware，就是一个view的包装，我想说的是WeakReference在android中很常用呀。 -- 这句是废话</p>

<p><code>
使用ImageAware占位
  图片宽高
  实际的View --可重用
  id -- 尼玛，这是解决问题的关键
</code></p>

<p>见DisplayBitmapTask有个isViewWasReused倒出重点，从它的实现就可以判断完整的算法拉。</p>

<p>内部结构 cacheKeysForImageAwares map&lt;ImageAware.id, memorycachekey(由URI + 宽高生成)></p>

<p>不过ViewAware的id是用view的hashcode来指定的， NonViewAware的id是用url来指定的。<br/>
so， listview的时候，使用loadImage是可以避免错乱的，而用displayImage就呵呵拉。<br/>
判断方式如下：根据id可以找到目前的url和当前的url比较即可。知道是不是被复用了。</p>

<p>相对于原理上的image#setTag(url)然后比较的方式，更加透明，侵入性少。</p>

<h2>再看看ImageLoaderEngine在任务管理、线程方面的处理</h2>

<p>原以为这货应该比较好处理，图样图森破呀，毕竟它支持多种状态(暂停，恢复，关闭等)</p>

<p>先说一下几个AtomicBoolean的变量，主要就是判断状态的boolean拉，当然这货是线程安全的，其实用boolean也行，毕竟也是原子的(注意可见性问题即可)
```</p>

<pre><code>private final AtomicBoolean paused = new AtomicBoolean(false);
private final AtomicBoolean networkDenied = new AtomicBoolean(false);
private final AtomicBoolean slowNetwork = new AtomicBoolean(false);`
</code></pre>

<p>```</p>

<p>另外，还有3个线程执行器，简单看看用途。至于为什么要这么多个，哥认为是这样的：</p>

<ul>
<li>在loader中走进displayImage之后，它重要检查一下内存中有木有(耗时小，无需线程)。</li>
<li>如果没有才会扔给engine，engine首先检查一下硬盘上有木有(有io，所以走taskDistributor)。</li>
<li>如果硬盘上有，走taskExecutorForCachedImages(同理有io)</li>
<li>还是没有，走其他(maybe网络io)</li>
<li>在请求较多，兼顾命中、不命中的情况，它选择了采用多级的Executor</li>
</ul>


<p>```</p>

<pre><code>private Executor taskExecutor; -- 木有在disk的情况，一般走网络
private Executor taskExecutorForCachedImages; -- 在disk的情况
private Executor taskDistributor;  -- 根据情况分发给上面2个
</code></pre>

<p>```</p>

<p>还有2个map，第一个就是用来保存id和图片url的对应关系(简单是这么理解)<br/>
另外是用来控制不同view但有相同uri的并发请求。
```</p>

<pre><code>private final Map&lt;Integer, String&gt; cacheKeysForImageAwares = Collections
        .synchronizedMap(new HashMap&lt;Integer, String&gt;());
private final Map&lt;String, ReentrantLock&gt; uriLocks = new WeakHashMap&lt;String, ReentrantLock&gt;();
</code></pre>

<p>```</p>

<p>不熟悉ReentrantLock的童鞋可参考 https://www.ibm.com/developerworks/cn/java/j-jtp10264/</p>

<p>LoadAndDisplayImageTask通过控制相同的uri持有同一个锁，这样执行的时候，后面的就会等待。<br/>
具体可以参考LoadAndDisplayImageTask的实现，不过用ReentrantLock需要特别注意写法，避免死锁。<br/>
不过我认为getLockForUri并没有同步，还是有存在相同url获取到不同lock的可能，不过这不影响功能，而且受限于并发大小也很难出现。</p>

<h2>关于url的中文</h2>

<p>网上有看到一些人说中文图片名会出错，可能是很久之前的版本吧。我这里要说的是，我认为这是个简单的问题，即使改源码也很容易处理。<br/>
不过即使源码有相关处理，通常也不会关注的，不过今天刚好有人问我一个中文路径的问题，所以我就关注了一下它怎么实现的。</p>

<p>首先看BaseImageDownloader是如何请求中文图片的。由于http只是支持ascii的url编码，所以必须要编码的，通常用utf-8,虽然这个没规定。貌似我们的基线没有考虑这个问题，应该是没有掉过坑。
```</p>

<pre><code>protected HttpURLConnection createConnection(String url, Object extra) throws IOException {
    String encodedUrl = Uri.encode(url, ALLOWED_URI_CHARS);
    HttpURLConnection conn = (HttpURLConnection) new URL(encodedUrl).openConnection();
    conn.setConnectTimeout(connectTimeout);
    conn.setReadTimeout(readTimeout);
    return conn;
}
</code></pre>

<p>```</p>

<p>另外，还有一个容易出现中文问题的就是保存到硬盘的情况(android貌似不是什么大问题，如果是做server开发的话，就得特别注意)<br/>
带的实现有HashCodeFileNameGenerator(默认)和Md5FileNameGenerator，这2种处理都不会产生中文问题。<br/>
不过我建议还是用Md5FileNameGenerator，hashcode做唯一性并不是很靠谱，如果是大量的固定文件名长度的图片，还是很容易冲突的。</p>

<h2>小结</h2>

<p>源码何其多，带着问题学习效果更好。挑几个疑惑看看别人怎么处理就是收获。  <br/>
从类的层次着手是很困难的，特别是大型源码。了解上层架构，学示例，然后调调源码或许更好。
大多数情况，相对于细节，应该更关注关键数据的结构、如何组织数据的结构来解决问题。<br/>
如果自己设计，应该考虑的重要问题有: 如何使用? 用怎样的结构表示数据和状态? <br/>
XX设计模式不要硬套，从过程式演变出来更加自然(经验性的除外)。推荐重构与模式。<br/>
大而全的源码解读没有什么用，带问题分析的更有价值。<br/>
学好基础，模仿起来也不容易掉坑。</p>

<p>-- 以上纯属肉眼分辨，并无调试过，不做正确性验证，仅供参考。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android+maven问题记录]]></title>
    <link href="http://mccxj.github.com/blog/20140219_android-maven-problems.html"/>
    <updated>2014-02-19T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/android-maven-problems</id>
    <content type="html"><![CDATA[<h2>参考材料</h2>

<ul>
<li>https://code.google.com/p/maven-android-plugin/wiki/GettingStarted</li>
<li>http://books.sonatype.com/mvnref-book/reference/android-dev.html</li>
<li>http://www.ikoding.com/build-android-project-with-maven/</li>
<li>https://github.com/mosabua/maven-android-sdk-deployer</li>
<li>http://rgladwell.github.io/m2e-android/</li>
<li>http://wiki.eclipse.org/M2E_plugin_execution_not_covered</li>
</ul>


<h2>前提条件</h2>

<ul>
<li>JDK 1.6+</li>
<li>Android SDK r21.1+</li>
<li>Maven 3.1.1+</li>
<li>Set environment variable ANDROID_HOME to the path of your installed Android SDK and add $ANDROID_HOME/tools as well as $ANDROID_HOME/platform-tools to your $PATH. (or on Windows %ANDROID_HOME%\tools and %ANDROID_HOME%\platform-tools)</li>
</ul>


<p>特别注意maven的版本号</p>

<h2>maven配置</h2>

<p>请设置环境变量M2_HOME，并把settings.xml放到M2_HOME/conf中去。</p>

<h2>eclipse配置</h2>

<p>对于eclipse来说，除了要maven插件，还需要<a href="http://rgladwell.github.io/m2e-android/">m2e-android</a>插件。</p>

<h2>dependency中support-v4的版本号只有很旧r7</h2>

<p>其实除了support-v4,像android也有类似的问题。有一种解决方案是采用<a href="https://github.com/mosabua/maven-android-sdk-deployer">maven-android-sdk-deployer</a>。
我测试过之后，发现这个解决方案虽然可行，但实际上比较麻烦。我直接在公司内的代理仓库上安装了新版本的。</p>

<h2>Plugin execution not covered by lifecycle configuration</h2>

<p>pom.xml很可能出现下面的错误提示:</p>

<p><code>bash
Plugin execution not covered by lifecycle configuration:
 com.jayway.maven.plugins.android.generation2:android-maven-plugin:3.8.2:consume-aar
 (execution: default-consume-aar, phase: compile)
</code></p>

<p>虽然不影响编译，但是很怪，可以通过下面的配置进行排除:</p>

<p>```xml
<pluginManagement></p>

<pre><code>&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt;
        &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;configuration&gt;
            &lt;lifecycleMappingMetadata&gt;
                &lt;pluginExecutions&gt;
                    &lt;pluginExecution&gt;
                        &lt;pluginExecutionFilter&gt;
                            &lt;groupId&gt;com.jayway.maven.plugins.android.generation2&lt;/groupId&gt;
                            &lt;artifactId&gt;android-maven-plugin&lt;/artifactId&gt;
                            &lt;versionRange&gt;3.8.2&lt;/versionRange&gt;
                            &lt;goals&gt;
                                &lt;goal&gt;manifest-update&lt;/goal&gt;
                                &lt;goal&gt;generate-sources&lt;/goal&gt;
                                &lt;goal&gt;proguard&lt;/goal&gt;
                                &lt;goal&gt;consume-aar&lt;/goal&gt;
                            &lt;/goals&gt;
                        &lt;/pluginExecutionFilter&gt;
                        &lt;action&gt;
                            &lt;ignore /&gt;
                        &lt;/action&gt;
                    &lt;/pluginExecution&gt;
                &lt;/pluginExecutions&gt;
            &lt;/lifecycleMappingMetadata&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>

<p></pluginManagement>
```</p>

<p>可以参考<a href="http://wiki.eclipse.org/M2E_plugin_execution_not_covered">M2E_plugin_execution_not_covered</a></p>

<h2>OutOfMemory或创建不了虚拟机</h2>

<p>有时候会出现内存溢出或创建不了虚拟机的错误。考虑设置内存大小</p>

<p>```xml
<plugin></p>

<pre><code>&lt;groupId&gt;com.jayway.maven.plugins.android.generation2&lt;/groupId&gt;
&lt;artifactId&gt;android-maven-plugin&lt;/artifactId&gt;
&lt;configuration&gt;
    &lt;dex&gt;
        &lt;jvmArguments&gt;
            &lt;jvmArgument&gt;-Xms256m&lt;/jvmArgument&gt;
            &lt;jvmArgument&gt;-Xmx512m&lt;/jvmArgument&gt;
        &lt;/jvmArguments&gt;
    &lt;/dex&gt;
&lt;/configuration&gt;
</code></pre>

<p></plugin>
```</p>

<h2>出现maven打包太慢的情况</h2>

<p>经过测量，在dex成classes.dex的阶段比较慢，dx工具有提供一些参数进行优化.</p>

<ul>
<li>incremental 增量打包，开发阶段可以开启，可以比较明显的缩短打包时间</li>
<li>optimize 是否优化classes.dex，开发阶段可以关闭</li>
</ul>


<p><code>xml
&lt;dex&gt;
  &lt;incremental&gt;true&lt;/incremental&gt;
  &lt;optimize&gt;false&lt;/optimize&gt;
&lt;/dex&gt;
</code></p>

<h2>libpng error: Not a PNG file</h2>

<p>如果直接把jpg格式换个名字，变成png，编译会报下面的错误，导致后面编译的.9图片也出问题(混淆问题的原因)</p>

<p><code>bash
[INFO] libpng error: Not a PNG file
[INFO] ERROR: Failure processing PNG image E:\projects\G3ESOP\ESOP-Hubei2\res\drawable-xhdpi\more_about_pic1.png
</code></p>

<h2>'build.plugins.plugin.version' is missing</h2>

<p><code>bash
[WARN] 'build.plugins.plugin.version' is missing fororg.apache.maven.plugins:maven.compiler.plugin
It is highly recommended to fix these problems because they threaten the stability of your build.
For this reason, future Maven versions might no longer support building such malformed projects.
</code></p>

<p>很简单，给maven.compiler.plugin这个插件添加version属性。
其实所有引用的插件都应该指定版本，不然都会有类似的提示。</p>

<h2>关于编码</h2>

<p>对于源码的编码格式和编译版本，应该进行指定:</p>

<p>```xml
<plugin></p>

<pre><code>&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
&lt;version&gt;3.1&lt;/version&gt;
&lt;configuration&gt;
    &lt;source&gt;1.6&lt;/source&gt;
    &lt;target&gt;1.6&lt;/target&gt;
    &lt;encoding&gt;UTF8&lt;/encoding&gt;
&lt;/configuration&gt;
</code></pre>

<p></plugin>
```</p>

<p>对于资源处理的话，可能出现下面的提示:</p>

<p><code>bash
[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!
</code></p>

<p>这个应该设置成UTF-8，如下所示:</p>

<p>```xml</p>

<pre><code>        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
            &lt;configuration&gt;
                &lt;encoding&gt;UTF-8&lt;/encoding&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
</code></pre>

<p>```</p>

<h2>maven-jarsigner-plugin对带特殊字符的口令的处理</h2>

<p>这个弄了好久，最后发现得把密码用引用引起来。切记切记。</p>

<p>后来，发现在linux这样又不能支持。所以只能用profile解决。</p>

<h2>部分代码在jdk7中编译后dex出错</h2>

<p>参考<a href="/blog/20140225_android-jdk7-bug.html">jdk7编译的bug记录</a>,暂时只用jdk6编译</p>

<h2>jdk6不支持android-19的proguard</h2>

<p>原因是android-19的API实现了一些jdk7的特性，在proguard会找不到这些api。
由于和上一个问题有些冲突，暂时不考虑proguard。后续考虑考虑上jdk7。</p>

<h2>如何添加.so支持</h2>

<p>例如下面的百度地图SDK，需要加入一个so文件，在百度SDK里边是这样调用的：</p>

<p><code>java
System.loadLibrary("BaiduMapSDK_v2_3_1");
</code></p>

<p>如果要用maven集成的话，可以用下面的配置(已经部署到代理仓库):</p>

<p>```xml
<dependency></p>

<pre><code>&lt;groupId&gt;com.baidu&lt;/groupId&gt;
&lt;artifactId&gt;libBaiduMapSDK_v2_3_1&lt;/artifactId&gt;
&lt;version&gt;2.3.1&lt;/version&gt;
&lt;classifier&gt;armeabi&lt;/classifier&gt;
&lt;scope&gt;runtime&lt;/scope&gt;
&lt;type&gt;so&lt;/type&gt;
</code></pre>

<p></dependency>
```</p>

<h2>如何转换成eclipse项目</h2>

<p>项目目录中只有pom.xml，如果要导入eclipse的话，可以考虑使用下面的命令生成.project和.classpath文件</p>

<p><code>bash
mvn eclipse:eclipse
</code></p>

<p>生成之后可能会有M2_REPO变量找不到的问题，可以在eclipse中通过window>Preferences>Maven>Installations>Add进行添加maven安装位置。</p>

<p>否则的话，可以按以下方法添加M2_REPO: Window > Preferences > Java > Build Path > Classpath Variables
新增一个M2_REPO变量指向你maven本地仓库。</p>

<h2>常用命令</h2>

<p>mvn clean package<br/>
打包，但不部署。</p>

<p>mvn clean install<br/>
打包，部署并运行。</p>

<p>mvn clean package android:redeploy android:run<br/>
这个命令通常用于手机上已经安装了要部署的应用，但签名不同，所以我们打包的同时使用redeploy命令将现有应用删除并重新部署，最后使用run命令运行应用。</p>

<p>mvn android:redeploy android:run<br/>
不打包，将已生成的包重新部署并运行。</p>

<p>mvn android:deploy android:run<br/>
部署并运行已生成的包，与redeploy不同的是，deploy不会删除已有部署和应用数据</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对UC文章《实时监控Android设备网络包》的补充]]></title>
    <link href="http://mccxj.github.com/blog/20131227_android-tcpdump-netcat-addon.html"/>
    <updated>2013-12-27T00:00:00+08:00</updated>
    <id>http://mccxj.github.com/blog/android-tcpdump-netcat-addon</id>
    <content type="html"><![CDATA[<p>补充的内容，主要是一些细节的问题，备忘.</p>

<h2>编译netcat</h2>

<p>android上自己好像带了一个，不过也可以自己编译一个。 我这里使用cygwin来编译的，首先去下载源码。</p>

<p>```bash</p>

<h1>cygwin</h1>

<p>cd /cygdrive/d/
mkdir -p netcat/toolchain</p>

<p>export NDK=/cygdrive/d/android-ndk-r8e
/cygdrive/d/android-ndk-r8e/build/tools/make-standalone-toolchain.sh --platform=android-8 --install-dir=netcat/toolchain
export PATH='pwd'/netcat/toolchain/bin:$PATH
export CC=arm-linux-androideabi-gcc
export RANLIB=arm-linux-androideabi-ranlib
export AR=arm-linux-and roideabi-ar
export LD=arm-linux-androideabi-ld</p>

<h1>开始编译源码</h1>

<p>cd netcat-0.7.1/
./configure —host=arm-linux
make</p>

<h1>用file进行检测一下</h1>

<p>file src/netcat
src/netcat: ELF 32-bit LSB executable, ARM, version1 (SYSV), ...</p>

<h1>发到android上去</h1>

<p>adb push src/netcat /data/local/netcat
adb shell chmod 777 /data/local/netcat
```</p>

<h2>tcpdump的使用</h2>

<p>如果只是监听所有的包，可以用下面的：
<code>bash
adb shell "tcpdump -n -s 0 -w - | nc -I -p 11233"
</code></p>

<p>如果先监听端口的话，又想转发的话，写法有点特别。
<code>bash
adb shell "tcpdump -X -n -s 0 -w - port 5000 | nc -l -p 11233"
</code></p>

<p>另外，如果像我这样，有cygwin的话，就已经有nc命令了，可以像下面一样进行转发。
<code>bash
adb forward tcp:11333 tcp:11233 &amp;&amp; nc -v 127.0.0.1 | /cygdriver/d/Wireshark/Wireshark.exe -k -S -i -
</code></p>
]]></content>
  </entry>
  
</feed>
